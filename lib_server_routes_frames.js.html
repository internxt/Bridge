<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Storj Bridge Source: lib/server/routes/frames.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<script src="scripts/highlight.min.js"></script>

	<link type="text/css" rel="stylesheet" href="styles/site.storj.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" style="background-image:url(img/storj-bridge.svg)"  href="index.html">Storj Bridge</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-storj-bridge.html">storj-bridge</a></li><li><a href="module-storj-bridge_constants.html">storj-bridge/constants</a></li><li><a href="module-storj-bridge_logger.html">storj-bridge/logger</a></li><li><a href="module-storj-bridge_utils.html">storj-bridge/utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="BucketsRouter.html">BucketsRouter</a></li><li><a href="Config.html">Config</a></li><li><a href="ContactsRouter.html">ContactsRouter</a></li><li><a href="Engine.html">Engine</a></li><li><a href="FramesRouter.html">FramesRouter</a></li><li><a href="PublicKeysRouter.html">PublicKeysRouter</a></li><li><a href="ReportsRouter.html">ReportsRouter</a></li><li><a href="Router.html">Router</a></li><li><a href="Server.html">Server</a></li><li><a href="StripeRouter.html">StripeRouter</a></li><li><a href="UsersRouter.html">UsersRouter</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-auth.html">API Authentication</a></li><li><a href="tutorial-config_.html">Configuring the Bridge</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#Cleaner">Cleaner</a></li><li><a href="global.html#Monitor">Monitor</a></li>
				</ul>
			</li>
			
		</ul>
		<div class="col-sm-3 col-md-4">
            <form class="navbar-form" role="search">
                <div class="input-group">
                    <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                    <div class="input-group-btn">
                        <button class="btn btn-primary" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                    </div>
                </div>
            </form>
        </div>
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: lib/server/routes/frames.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript ">'use strict';

const async = require('async');
const storj = require('storj-lib');
const middleware = require('storj-service-middleware');
const crypto = require('crypto');
const authenticate = middleware.authenticate;
const errors = require('storj-service-error-types');
const Router = require('./index');
const inherits = require('util').inherits;
const ms = require('ms');
const log = require('../../logger');
const constants = require('../../constants');
const { MAX_SHARD_SIZE } = require('storj-service-storage-models').constants;
const analytics = require('storj-analytics');
const limiter = require('../limiter').DEFAULTS;
const utils = require('../../utils');

/**
 * Handles endpoints for all frame/file staging related operations
 * @constructor
 * @extends {Router}
 */
function FramesRouter(options) {
  if (!(this instanceof FramesRouter)) {
    return new FramesRouter(options);
  }

  Router.apply(this, arguments);
  this._defaults = options.config.application;
  this._verify = authenticate(this.storage);
  this.getLimiter = middleware.rateLimiter(options.redis);
}

inherits(FramesRouter, Router);

/**
 * Creates a file staging frame
 * @param {http.IncomingMessage} req
 * @param {http.ServerResponse} res
 * @param {Function} next
 */
FramesRouter.prototype.createFrame = async function (req, res, next) {

  const Frame = this.storage.models.Frame;

  
  let spaceLeft = await userHasFreeSpaceLeft(this.storage, req.user.email);
  if (!spaceLeft.canUpload) {
    log.warn('User %s exceeded limit, no uploads allowed', req.user.id);
    return next(new errors.TransferRateError('Max. space used'));
  }
  

  const rates = this.config.application.freeTier.up;
  if (req.user.isUploadRateLimited(rates.hourlyBytes,
    rates.dailyBytes,
    rates.monthlyBytes)) {
    log.warn('createFrame: Transfer rate limited, user: %s', req.user.email);
    analytics.track(req.headers.dnt, {
      userId: req.user.uuid,
      event: 'User Upload Rate Limited',
      properties: {
        monthlyBytes: req.user.bytesUploaded.lastMonthBytes,
        dailyBytes: req.user.bytesUploaded.lastDayBytes,
        hourlyBytes: req.user.bytesUploaded.lastHourBytes
      }
    });
    return next(new errors.TransferRateError(
      'Could not create frame, transfer rate limit reached.'
    ));
  }

  analytics.track(req.headers.dnt, {
    userId: req.user.uuid,
    event: 'Frame Created'
  });

  Frame.create(req.user, function (err, frame) {
    if (err) {
      return next(new errors.InternalError(err.message));
    }

    res.send(frame.toObject());
  });
};


/**
 * Negotiates a contract and updates persistence for the given contract data
 * @private
 * @param {storj.Contract} contract - The contract object to publish
 * @param {storj.AuditStream} audit - The audit object to add to persistence
 * @param {Array} blacklist - Do not accept offers from these nodeIDs
 * @param {Object} res - The associated response
 * @param {Function} callback - Called with error or (farmer, contract)
 */
FramesRouter.prototype._getContractForShard = function (contr, audit, bl, res, done) {
  const self = this;
  const hash = contr.get('data_hash');

  self.contracts.load(hash, function (err, item) {
    if (err) {
      item = new storj.StorageItem({ hash: hash });
    }

    self.network.getStorageOffer(contr, bl, function (err, farmer, contract) {
      if (err) {
        return done(err);
      }

      // NB: This can happen even if the client times out and the contract
      // would be added to the item even though the client never had a chance
      // to upload the data to the farmer
      if (res.socket.destroyed) {
        return;
      }

      item.addContract(farmer, contract);
      item.addAuditRecords(farmer, audit);
      item.addMetaData(farmer, { downloadCount: 0 });

      self.contracts.save(item, function (err) {
        if (err) {
          return done(new errors.InternalError(err.message));
        }

        done(null, farmer, contract);
      });
    });
  });
};

/**
 * Negotiates a contract and updates persistence for the given contract data
 * @private
 * @param {storj.Contract} contract - The contract object to publish
 * @param {storj.AuditStream} audit - The audit object to add to persistence
 * @param {Array} blacklist - Do not accept offers from these nodeIDs
 * @param {Object} res - The associated response
 * @param {Function} callback - Called with error or (farmer, contract)
 */
FramesRouter.prototype._getContractForShardSIP6 = function (contr, audit, bl, res, done) {
  this._selectFarmers(bl, (err, farmers) => {
    if (err) {
      return done(new errors.InternalError(err.message));
    }

    if (!farmers || !farmers.length) {
      return done(new errors.InternalError('Could not locate farmers'));
    }

    this._publishContract(farmers, contr, audit, (err, farmerContact, farmerContract, token) => {
      if (err) {
        return done(new errors.InternalError(err.message));
      }

      done(null, farmerContact, farmerContract, token);
    });
  });
};

FramesRouter._sortByResponseTime = function (a, b) {
  const aTime = a.contact.responseTime || Infinity;
  const bTime = b.contact.responseTime || Infinity;
  return (aTime === bTime) ? 0 : (aTime > bTime) ? 1 : -1;
};

FramesRouter._sortByReputation = function(a, b) {
    const aVal = a.contact.reputation || Infinity;
    const bVal = b.contact.reputation || Infinity;
    return (aVal === bVal) ? 0 : (aVal > bVal) ? 1 : -1;
};

FramesRouter.prototype._selectFarmers = function(excluded, callback) {
  async.parallel([
    (next) => {
      this.storage.models.Contact.find({
        _id: { $lte: crypto.randomBytes(20).toString('hex'), $nin: excluded },
        reputation: { $gt: this._defaults.publishBenchThreshold },
        spaceAvailable: true
      }).sort({ _id: -1 })
        .limit(this._defaults.publishTotal)
        .exec(next);
    },
    (next) => {
      this.storage.models.Contact.find({
        _id: { $lte: crypto.randomBytes(20).toString('hex'), $nin: excluded },
        reputation: { $lte: this._defaults.publishBenchThreshold },
        spaceAvailable: true
      }).sort({ _id: -1 })
        .limit(this._defaults.publishBenchTotal)
        .exec(next);
    }
  ], (err, results) => {
    if (err) {
      return callback(err);
    }
    const combined = results[0].concat(results[1]);
    callback(null, combined);
  });
};

FramesRouter.prototype._publishContract = function (nodes, contract, audit, callback) {
  const hash = contract.get('data_hash');

  this.contracts.load(hash, (err, item) => {
    if (err) {
      item = new storj.StorageItem({ hash: hash });
    }

    this.network.publishContract(nodes, contract, (err, data) => {
      if (err) {
        return callback(err);
      }

      const farmerContact = storj.Contact(data.contact);
      const farmerContract = storj.Contract(data.contract);

      item.addContract(farmerContact, farmerContract);
      item.addAuditRecords(farmerContact, audit);

      this.contracts.save(item, (err) => {
        if (err) {
          return callback(new errors.InternalError(err.message));
        }

        callback(null, farmerContact, farmerContract, data.token);
      });
    });
  });
};

/**
 * Negotiates a storage contract and adds the shard to the frame
 * @param {http.IncomingMessage} req
 * @param {http.ServerResponse} res
 * @param {Function} next
 */
FramesRouter.prototype.addShardToFrame = function (req, res, next) {
  /* jshint maxstatements: 25 */
  const self = this;
  const Frame = this.storage.models.Frame;
  const Pointer = this.storage.models.Pointer;

  const rates = self.config.application.freeTier.up;
  if (req.user.isUploadRateLimited(rates.hourlyBytes,
    rates.dailyBytes,
    rates.monthlyBytes)) {
    log.warn('addShardToFrame: Transfer rate limited, user: %s', req.user.email);
    analytics.track(req.headers.dnt, {
      userId: req.user.uuid,
      event: 'User Upload Rate Limited',
      properties: {
        monthlyBytes: req.user.bytesUploaded.lastMonthBytes,
        dailyBytes: req.user.bytesUploaded.lastDayBytes,
        hourlyBytes: req.user.bytesUploaded.lastHourBytes
      }
    });
    return next(new errors.TransferRateError(
      'Could not add shard to frame, transfer rate limit reached.'
    ));
  }

  if (req.body.size > MAX_SHARD_SIZE) {
    return next(new errors.BadRequestError('Maximum shard size ' +
      MAX_SHARD_SIZE + ' exceeded'));
  }

  if (Array.isArray(req.body.exclude) &amp;&amp;
    req.body.exclude.length > constants.MAX_BLACKLIST) {
    return next(new errors.BadRequestError('Maximum blacklist length'));
  }

  let audit;
  let contr;

  try {
    audit = storj.AuditStream.fromRecords(
      req.body.challenges,
      req.body.tree
    );
  } catch (err) {
    return next(new errors.BadRequestError(err.message));
  }

  try {
    contr = new storj.Contract({
      data_size: req.body.size,
      data_hash: req.body.hash,
      store_begin: Date.now(),
      store_end: Date.now() + ms('365d'),
      audit_count: req.body.challenges.length
    });
  } catch (err) {
    return next(new errors.BadRequestError(err.message));
  }

  let bl = Array.isArray(req.body.exclude) ? req.body.exclude : [];
  let frame = null;
  let farmer = null;
  let contract = null;
  let token = null;

  async.series([
    function checkFrame(done) {
      Frame.findOne({
        _id: req.params.frame,
        user: req.user._id
      }, function (err, _frame) {
        if (err) {
          return done(new errors.InternalError(err.message));
        }

        if (!_frame) {
          done(new errors.NotFoundError('Frame not found'));
        } else {
          frame = _frame;
          done();
        }
      });
    },
    function getContract(done) {
      // First check that we don't already have cached offers for this
      // shard from a previous request that timed out with offers that
      // arrived late.

      self.storage.models.Mirror.find({
        shardHash: req.body.hash
      }).populate('contact').exec((err, mirrors) => {
        if (err) {
          log.error(err.message);
        }

        let mirror = null;
        if (mirrors &amp;&amp; mirrors.length) {
          const filtered = mirrors.filter((m) => {
            if (!m.contact) {
              log.warn('Mirror %s is missing contact in database', m._id);
              return false;
            } else if (!m.isEstablished) {
              return true;
            }
            return false;
          });

          let blackListFiltered = filtered.filter((mirrorContact) =>
            !bl.includes(mirrorContact.contact.nodeID)
          );

          blackListFiltered.sort(utils.sortByReputation);

          mirror = blackListFiltered[0];
        }

        if (!mirror) {
          // If we don't have any cached offers go ahead and send out
          // a call into the network for more offers

          log.debug('Requesting contract for frame: %s, shard hash: %s and size: %s',
            req.params.frame, req.body.hash, req.body.size);

          // Check if SIP6 is activated, otherwise we'll continue to use the
          // existing implementation. Once this has fully been deployed, this
          // switch can be removed and SIP6 used exclusively.
          let getContractForShard = self._defaults.activateSIP6 ?
            self._getContractForShardSIP6.bind(self) :
            self._getContractForShard.bind(self);

          getContractForShard(contr, audit, bl, res, function (err, _contact, _contract, _token) {
            if (err) {
              log.warn('Could not get contract for frame: %s and ' +
                'shard hash: %s, reason: %s', req.params.frame,
                req.body.hash, err.message);
              done(new errors.ServiceUnavailableError(err.message));
            } else {
              farmer = _contact;
              contract = _contract;

              // Only set the token if SIP6 is activated, this value will be
              // undefined without it. Once SIP6 is fully activated, this check
              // can be removed.
              if (self._defaults.activateSIP6) {
                token = _token;
              }

              done();
            }
          });
        } else {

          token = mirror.token;

          self.contracts.load(req.body.hash, function (err, item) {
            if (err) {
              item = new storj.StorageItem({ hash: req.body.hash });
            }

            mirror.isEstablished = true;
            mirror.save();

            farmer = storj.Contact(mirror.contact);
            contract = storj.Contract(mirror.contract);

            item.addContract(farmer, contract);
            item.addAuditRecords(farmer, audit);

            self.contracts.save(item, function (err) {
              if (err) {
                return done(new errors.InternalError(err.message));
              }
              done();
            });
          });
        }
      });
    },
    function getToken(done) {
      if (self._defaults.activateSIP6) {
        // There is no need to get the token seperately with SIP6,
        // we can skip this step. Once SIP6 is fully activated, this
        // step can be completely removed.
        return done();
      }
      self.network.getConsignmentPointer(
        farmer, contract, audit,
        function (err, dcPointer) {
          if (err) {
            log.warn('Could not get consignment pointer for frame: %s, ' +
              'shard hash: %s, reason: %s', req.params.frame,
              req.body.hash, err.message);
            done(new errors.ServiceUnavailableError(err.message));
          } else {
            token = dcPointer.token;
            done();
          }
        });
    },
    function addPointerToFrame(done) {

      let pointerData = {
        index: req.body.index,
        hash: req.body.hash,
        size: req.body.size,
        tree: req.body.tree,
        parity: req.body.parity,
        challenges: req.body.challenges
      };

      Pointer.create(pointerData, function (err, pointer) {
        if (err) {
          return done(new errors.BadRequestError(err.message));
        }

        // We need to reload the frame to get the latest copy
        Frame.findOne({
          _id: frame._id
        }).populate('shards').exec(function (err, frame) {
          if (err) {
            return done(new errors.InternalError(err.message));
          }

          req.user.recordUploadBytes(pointer.size, (err) => {
            if (err) {
              log.warn(
                'addShardToFrame: unable to save upload bytes %s, ' +
                'user: %s, reason: %s', pointer.size, req.user.email,
                err.message
              );
            }
          });

          frame.addShard(pointer, (err) => {
            if (err) {
              return done(new errors.InternalError(err.message));
            }
            res.send({
              hash: req.body.hash,
              token: token,
              operation: 'PUSH',
              farmer: farmer
            });
          });
        });
      });
    }
  ], next);
};

/**
 * Destroys the file staging frame if it is not in use by a bucket entry
 * @param {http.IncomingMessage} req
 * @param {http.ServerResponse} res
 * @param {Function} next
 */
FramesRouter.prototype.destroyFrameById = function (req, res, next) {
  const BucketEntry = this.storage.models.BucketEntry;
  const Frame = this.storage.models.Frame;

  BucketEntry.findOne({
    user: req.user._id,
    frame: req.params.frame
  }, function (err, entry) {
    if (err) {
      return next(new errors.InternalError(err.message));
    }

    if (entry) {
      return next(new errors.BadRequestError(
        'Refusing to destroy frame that is referenced by a bucket entry'
      ));
    }

    Frame.findOne({
      user: req.user._id,
      _id: req.params.frame
    }, function (err, frame) {
      if (err) {
        return next(new errors.InternalError(err.message));
      }

      if (!frame) {
        return next(new errors.NotFoundError('Frame not found'));
      }

      frame.remove(function (err) {
        if (err) {
          return next(new errors.InternalError(err.message));
        }

        res.status(204).end();
      });
    });
  });
};

/**
 * Returns the caller's file staging frames
 * @param {http.IncomingMessage} req
 * @param {http.ServerResponse} res
 * @param {Function} next
 */
FramesRouter.prototype.getFrames = function (req, res, next) {
  const Frame = this.storage.models.Frame;

  Frame.find({ user: req.user._id }).limit(10).exec(function (err, frames) {
    if (err) {
      return next(new errors.InternalError(err.message));
    }

    res.send(frames.map(function (frame) {
      return frame.toObject();
    }));
  });
};

/**
 * Returns the file staging frame by it's ID
 * @param {http.IncomingMessage} req
 * @param {http.ServerResponse} res
 * @param {Function} next
 */
FramesRouter.prototype.getFrameById = function (req, res, next) {
  const Frame = this.storage.models.Frame;

  Frame.findOne({
    user: req.user._id,
    _id: req.params.frame
  }, function (err, frame) {
    if (err) {
      return next(new errors.InternalError(err.message));
    }

    if (!frame) {
      return next(new errors.NotFoundError('Frame not found'));
    }

    res.send(frame.toObject());
  });
};

function getStorageUsage(storage, user) {
  const Bucket = storage.models.Bucket;

  return new Promise((resolve, reject) => {
    var agg = Bucket.aggregate([
      {
        $match: {
          user: user
        }
      },
      {
        $lookup: {
          from: 'bucketentries',
          localField: '_id',
          foreignField: 'bucket',
          as: 'join1'
        }
      },
      {
        $unwind: {
          path: '$join1'
        }
      },
      {
        $lookup: {
          from: "frames",
          localField: "join1.frame",
          foreignField: "_id",
          as: "join2"
        }
      },
      {
        $unwind: {
          path: '$join2'
        }
      },
      {
        $project: {
          _id: '$join2._id',
          user: '$join2.user',
          size: '$join2.size'
        }
      },
      {
        $group: {
          _id: '$user',
          total: { $sum: '$size' }
        }
      }
    ]).cursor({ batchSize: 1000 }).exec();

    agg.next().then(data => {
      resolve(data);
    }).catch(err => {
      reject({ message: 'Error', reason: err });
    });
  });
}

function getStorageLimit(storage, user) {
  return new Promise((resolve, reject) => {

    storage.models.User.findOne({ _id: user }, function (err, _user) {
      if (err) {
        reject({ error: 'Internal error', statusCode: 500 });
      }
  
      if (!_user) {
        reject({ error: 'User not found', statusCode: 404 });
      }
  
      if (_user.maxSpaceBytes == 0) {
        _user.maxSpaceBytes = 1024 * 1024 * 1024;
      }
  
      resolve({ error: null, statusCode: 200, maxSpaceBytes: _user.maxSpaceBytes });
    })
  
  });
}

function userHasFreeSpaceLeft(storage, user) {
  return new Promise((resolve, reject) => {
    getStorageLimit(storage, user).then(limit => {
      const maxSpaceBytes = limit.maxSpaceBytes;
      getStorageUsage(storage, user).then(usage => {
        const usedSpaceBytes = usage ? usage.total : 0;
        // If !maxSpaceBytes models are not updated. Consider no limit due to this variable.
        resolve({ canUpload: !maxSpaceBytes ? true : usedSpaceBytes &lt; maxSpaceBytes });
      }).catch(err => {
        resolve({ canUpload: false, error: err.message });
      });
  
    }).catch(err => {
      resolve({ canUpload: false, error: err.message });
    });
  });
}

FramesRouter.prototype.getStorageUsage = function (req, res, next) {
  getStorageUsage(this.storage, req.user._id)
  .then(usage => {
    if (!usage) {
      usage = { total: 0 };
    }
    res.status(200).send(usage);
  })
  .catch(err => {
    res.status(400).send({ message: 'Error' });
  });
}

FramesRouter.prototype.getStorageLimit = function (req, res, next) {
  getStorageLimit(this.storage, req.user._id).then(result => {
    res.status(result.statusCode).send({ maxSpaceBytes: result.maxSpaceBytes });
  }).catch(err => {
    res.status(result.statusCode).send({ error: err.error });
  });
};


/**
 * Export definitions
 * @private
 */
FramesRouter.prototype._definitions = function () {
  /* jshint maxlen: 140 */
  return [
    ['POST', '/frames', this.getLimiter(limiter(1000)), this._verify, this.createFrame],
    ['PUT', '/frames/:frame', this.getLimiter(limiter(this._defaults.shardsPerMinute)), this._verify, this.addShardToFrame],
    ['DELETE', '/frames/:frame', this.getLimiter(limiter(1000)), this._verify, this.destroyFrameById],
    ['GET', '/frames', this.getLimiter(limiter(1000)), this._verify, this.getFrames],
    ['GET', '/frames/:frame', this.getLimiter(limiter(1000)), this._verify, this.getFrameById],
    ['GET', '/usage', this.getLimiter(limiter(1000)), this._verify, this.getStorageUsage],
    ['GET', '/limit', this.getLimiter(limiter(1000)), this._verify, this.getStorageLimit]
  ];
};

module.exports = FramesRouter;</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>

<div class="modal fade" id="searchResults">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Search results</h4>
      </div>
      <div class="modal-body"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div>

<footer>


	<span class="copyright">
	Copyright 2016 Storj Labs
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>
<script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>

<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	$('pre').each(function(i, block) {
		hljs.highlightBlock(block);
	});

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			var id = $( heading ).attr( "id" );
			return id && id.replace(/\~/g, '-inner-').replace(/\./g, '-static-') || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->


<script type="text/javascript">
	$(document).ready(function() {
		SearcherDisplay.init();
	});
</script>

</body>
</html>
