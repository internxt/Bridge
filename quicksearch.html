<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_server_routes_buckets.js.html":{"id":"lib_server_routes_buckets.js.html","title":"Source: lib/server/routes/buckets.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/buckets.js 'use strict'; const ms = require('ms'); const assert = require('assert'); const async = require('async'); const storj = require('storj-lib'); const middleware = require('storj-service-middleware'); const authenticate = middleware.authenticate; const tokenauth = middleware.tokenauth; const publicBucket = middleware.publicBucket; const log = require('../../logger'); const merge = require('merge'); const mongoose = require('mongoose'); const errors = require('storj-service-error-types'); const Router = require('./index'); const inherits = require('util').inherits; const utils = require('../../utils'); const constants = require('../../constants'); const analytics = require('storj-analytics'); const limiter = require('../limiter').DEFAULTS; /** * Handles endpoints for all bucket and file related operations * @constructor * @extends {Router} */ function BucketsRouter(options) { if (!(this instanceof BucketsRouter)) { return new BucketsRouter(options); } Router.apply(this, arguments); this._verify = authenticate(this.storage); this._isPublic = publicBucket(this.storage); this._usetoken = tokenauth(this.storage); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(BucketsRouter, Router); BucketsRouter.prototype._usetokenOrVerify = function (req, res, next) { if (req.headers['x-token']) { this._usetoken(req, res, next); } else { // NB: Authenticate middleware is array of rawbody and authenticate assert(this._verify.length === 2); const rawbody = this._verify[0]; const authenticate = this._verify[1]; rawbody(req, res, (err) =&gt; { if (err) { return next(err); } authenticate(req, res, next); }); } }; BucketsRouter.prototype._validate = function (req, res, next) { if (req.params.id &amp;&amp; !utils.isValidObjectId(req.params.id)) { return next(new errors.BadRequestError('Bucket id is malformed')); } if (req.params.file &amp;&amp; !utils.isValidObjectId(req.params.file)) { return next(new errors.BadRequestError('File id is malformed')); } next(); }; /** * Returns a list of buckets for the user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.getBuckets = function (req, res, next) { let findQuery = { user: req.user._id }; const startDate = utils.parseTimestamp(req.query.startDate); if (startDate) { findQuery.created = { $gt: startDate }; } this.storage.models.Bucket .find(findQuery) .sort({ created: 1 }) .limit(constants.DEFAULT_MAX_BUCKETS) .exec(function (err, buckets) { if (err) { return next(new errors.InternalError(err.message)); } res.status(200).send(buckets.map(function (bucket) { return bucket.toObject(); })); }); }; /** * Returns the user's bucket by it's ID * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.getBucketById = function (req, res, next) { const Bucket = this.storage.models.Bucket; Bucket.findOne({ _id: req.params.id, user: req.user._id }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } res.status(200).send(bucket.toObject()); }); }; BucketsRouter.prototype.getBucketId = function (req, res, next) { const Bucket = this.storage.models.Bucket; Bucket.findOne({ user: req.user._id, name: req.params.name }, '_id', { lean: true }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } res.status(200).send({ id: bucket._id }); }); }; /** * Creates a new bucket for the user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.createBucket = function (req, res, next) { const Bucket = this.storage.models.Bucket; const PublicKey = this.storage.models.PublicKey; if (req.body.name &amp;&amp; req.body.name.length &gt; constants.MAX_BUCKETNAME) { return next(new errors.BadRequestError('Maximum bucket name')); } if (!Array.isArray(req.body.pubkeys)) { req.body.pubkeys = []; } if (req.pubkey &amp;&amp; req.body.pubkeys.indexOf(req.pubkey._id) === -1) { req.body.pubkeys.push(req.pubkey._id); } try { for (let k = 0; k &lt; req.body.pubkeys.length; k++) { PublicKey.validate(req.body.pubkeys[k]); } } catch (err) { return next(new errors.BadRequestError('Invalid public key supplied')); } analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Bucket Created' }); Bucket.create(req.user, req.body, function (err, bucket) { if (err) { return next(err); } res.status(201).send(bucket.toObject()); }); }; /** * Destroys the user's bucket by ID * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.destroyBucketById = function(req, res, next) { const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; const StorageEvent = this.storage.models.StorageEvent; const bucketObjectId = new mongoose.Types.ObjectId(req.params.id); analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Bucket Destroyed' }); BucketEntry.aggregate([ { $match: { bucket: bucketObjectId } }, { $lookup: { from: 'frames', localField: 'frame', foreignField: '_id', as: 'frameData' } }, { $unwind: { path: '$frameData' } }, { $project: { _id: 0, bucket: '$bucket', bucketEntry: '$_id', user: {$literal: req.user._id}, downloadBandwidth: {$literal: 0}, storage: {$multiply: [-1, '$frameData.size']}, timestamp: {$add: [new Date(), 0]} } }], function(err, storageEvents) { if (err) { log.warn('destroyBucketById: storage event aggregation failed, reason: %s', err.message); } Bucket.findOne({ _id: req.params.id, user: req.user._id }, function(err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } bucket.remove(function(err) { if (err) { return next(new errors.InternalError(err.message)); } BucketEntry.remove({ bucket: req.params.id }, (err) =&gt; { if (err) { log.error('Unable to remove bucket entries, reason: %s', err.message); } StorageEvent.collection.insert(storageEvents, function(err) { if (err) { log.warn('Unable to save storage events, reason: %s', err.message); } }); }); }); res.status(204).end(); }); }); }; /** * Updates the given bucket's properties * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.updateBucketById = function (req, res, next) { const PublicKey = this.storage.models.PublicKey; const Bucket = this.storage.models.Bucket; Bucket.findOne({ _id: req.params.id, user: req.user._id }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } var allowed = ['pubkeys', 'encryptionKey', 'publicPermissions']; for (let prop in req.body) { if (allowed.indexOf(prop) !== -1) { bucket[prop] = req.body[prop]; } } try { for (let k = 0; k &lt; bucket.pubkeys.length; k++) { PublicKey.validate(bucket.pubkeys[k]); } } catch (err) { return next(new errors.BadRequestError('Invalid public key supplied')); } bucket.save(function (err) { if (err) { return next(new errors.InternalError(err.message)); } res.status(200).send(bucket.toObject()); }); }); }; /** * Loads the bucket for an authorized but unregistered user * @private * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype._getBucketUnregistered = function (req, res, next) { const self = this; const Bucket = this.storage.models.Bucket; let query = { _id: req.params.id }; let strategy = authenticate._detectStrategy(req); let rawBody = self._verify[0]; let checkAuth = self._verify[1]; let isPublicBucket = self._isPublic; function _checkAuthIfNotPublic(req, res, next) { isPublicBucket(req, res, function (err) { if (err) { return checkAuth(req, res, next); } next(null); }); } async.series([ rawBody.bind(null, req, res), _checkAuthIfNotPublic.bind(null, req, res) ], function (err) { if (err) { if (strategy === 'ECDSA' &amp;&amp; authenticate._verifySignature(req)) { query.pubkeys = { $in: [req.header('x-pubkey')] }; } else { return next(err); } } if (req.user) { query.user = req.user._id; } Bucket.findOne(query, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } next(null, bucket); }); }); }; /** * @callback BucketsRouter~_getBucketUnregisteredCallback * @param {Error|null} [error] * @param {Bucket} bucket */ /** * Creates a bucket operation token * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.createBucketToken = function (req, res, next) { const Token = this.storage.models.Token; const BucketEntry = this.storage.models.BucketEntry; const Bucket = this.storage.models.Bucket; Bucket.findOne({ _id: req.params.id, user: req.user._id }, function (err, bucket) { if (err) { return next(err); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Token Created', properties: { type: req.body.operation } }); Token.create(bucket, req.body.operation, function (err, token) { if (err) { return next(new errors.InternalError(err.message)); } var tokenObject = token.toObject(); tokenObject.encryptionKey = bucket.encryptionKey; var file = req.body.file; if (!file || req.body.operation !== 'PULL') { res.status(201).send(tokenObject); return; } BucketEntry.findOne({ _id: file, bucket: bucket._id }).populate('frame').exec(function (err, bucketEntry) { if (err) { return next(err); } if (!bucketEntry) { return next(new errors.NotFoundError('Bucket entry not found')); } tokenObject.mimetype = bucketEntry.mimetype; tokenObject.size = bucketEntry.frame.size; res.status(201).send(tokenObject); }); }); }); }; /** * Creates a bucket entry from the given frame object * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.createEntryFromFrame = function (req, res, next) { const Frame = this.storage.models.Frame; const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; const StorageEvent = this.storage.models.StorageEvent; if (req.body.filename &amp;&amp; req.body.filename.length &gt; constants.MAX_BUCKETENTRYNAME) { return next(new errors.BadRequestError('Maximum bucket entry name')); } analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'File Upload Complete' }); Bucket.findOne({ user: req.user._id, _id: req.params.id }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } Frame.findOne({ _id: req.body.frame, user: req.user._id }, function (err, frame) { if (err) { return next(new errors.InternalError(err.message)); } if (!frame) { return next(new errors.NotFoundError('Frame not found')); } if (frame.locked) { return next(new errors.BadRequestError('Frame is already locked')); } BucketEntry.create({ bucket: bucket._id, frame: frame._id, mimetype: req.body.mimetype, name: req.body.filename, hmac: req.body.hmac, erasure: req.body.erasure, index: req.body.index }, function (err, entry) { if (err) { return next(new errors.InternalError(err.message)); } frame.lock(function (err) { if (err) { return next(new errors.InternalError(err.message)); } var fileCreationStorageEventData = { bucket: req.params.id, bucketEntry: entry._id, user: req.user._id, downloadBandwidth: 0, storage: frame.storageSize }; var fileCreationStorageEvent = new StorageEvent(fileCreationStorageEventData); fileCreationStorageEvent.save(function (err) { if (err) { log.warn('createEntryFromFrame: failed to save storage event, reason: %s', err.message); } }); res.send(merge(entry.toObject(), { size: frame.size })); }); }); }); }); }; /** * Returns the bucket by ID * @param {String|ObjectId} bucketId - The unique _id for the bucket * @param {String} [userId] - The email address for the user * @param {BucketsRouter~_getBucketByIdCallback} */ BucketsRouter.prototype._getBucketById = function (bucketId, userId, callback) { var query = { _id: bucketId }; if (typeof userId === 'function') { callback = userId; userId = null; } if (userId) { query.user = userId; } this.storage.models.Bucket.findOne(query, function (err, bucket) { if (err) { return callback(new errors.InternalError(err.message)); } if (!bucket) { return callback(new errors.NotFoundError('Bucket not found')); } callback(null, bucket); }); }; /** * @callback BucketsRouter~_getBucketByIdCallback * @param {Error|null} error * @param {Bucket} bucket */ /** * Returns the bucket entry by ID * @param {String|ObjectId} bucketId - The unique _id for the bucket * @param {String} bucketEntryId - The unique _id for the bucket entry * @param {BucketsRouter~_getBucketEntryByIdCallback} */ BucketsRouter.prototype.getBucketEntryById = function (bucketId, entryId, done) { this.storage.models.BucketEntry.findOne({ _id: entryId, bucket: bucketId }).populate('frame').exec(function (err, entry) { if (err) { return done(new errors.InternalError(err.message)); } if (!entry) { return done(new errors.NotFoundError('Entry not found')); } done(null, entry); }); }; /** * @callback BucketsRouter~_getBucketEntryByIdCallback * @param {Error|null} error * @param {BucketEntry} bucketEntry */ /** * Returns the pointers for a given bucket entry * @param {BucketEntry} bucketEntry * @param {BucketsRouter~getPointersForEntryCallback} */ BucketsRouter.prototype.getPointersForEntry = function (bucketEntry, next) { this.storage.models.Pointer.find({ _id: { $in: bucketEntry.frame.shards } }, function (err, pointers) { if (err) { return next(new errors.InternalError(err.message)); } next(null, pointers); }); }; /** * @callback BucketsRouter~getPointersForEntryCallback * @param {Error|null} error * @param {Pointers[]} shardPointers */ /** * Returns possible mirroring candidates for a group of pointers * @param {Pointer} shardPointer * @param {BucketsRouter~getMirrorsForPointersCallback} */ BucketsRouter.prototype.getMirrorsForPointers = function (pointers, callback) { var self = this; var hashes = pointers.map(function (pointer) { return pointer.hash; }); async.map(hashes, function (hash, done) { self.storage.models.Mirror.find( { shardHash: hash, isEstablished: false }, done ); }, callback); }; /** * @callback BucketsRouter~getMirrorsForPointersCallback * @param {Error|null} error * @param {Array.&lt;Array.&lt;Mirror&gt;&gt;} mirrors */ /** * Retreives a contact by it's Node ID * @param {String} nodeId - Farmers public key hash * @param {BucketsRouter~getContactByIdCallback} */ BucketsRouter.prototype.getContactById = function (nodeId, callback) { this.storage.models.Contact.findOne({ _id: nodeId }, function (err, contact) { if (err) { return callback(new errors.InternalError(err.message)); } if (!contact) { return callback(new errors.NotFoundError('Contact not found')); } callback(null, contact); }); }; /** * @callback BucketsRouter~getContactByIdCallback * @param {Error|null} error * @param {Contact} contact */ /** * Authorizes a mirror node to retreive data from a source * @param {Mirror} mirror - The mirror object * @param {BucketsRouter~getMirrorAuthorizationCallback} */ BucketsRouter.prototype.getMirrorAuthorization = function (mirror, done) { var self = this; var contracts = this.contracts; var network = this.network; contracts.load(mirror.shardHash, function (err, item) { if (err) { return done(err); } var sourceIds = Object.keys(item.contracts); var sourceIdIndex = Math.floor(Math.random() * sourceIds.length); var sourceId = sourceIds[sourceIdIndex]; var sourceContract = item.contracts[sourceId]; async.parallel([ self.getContactById.bind(self, sourceId), self.getContactById.bind(self, mirror.contact) ], function (err, contacts) { if (err) { return done(err); } var [source, destination] = contacts.map((c) =&gt; new storj.Contact(c)); network.getRetrievalPointer(source, sourceContract, function (err, dcp) { if (err) { return done(err); } done(null, { mirror: mirror, source: dcp, destination: destination }); }); }); }); }; /** * @callback BucketsRouter~getMirrorAuthorizationCallback * @param {Error|null} error * @param {Object} mirrorAuth * @param {Mirror} mirrorAuth.mirror * @param {DataChannelPointer} mirrorAuth.source * @param {Contact} mirrorAuth.destination */ /** * Creates a mirror authorization pointer map * @param {Array.&lt;Array.&lt;Mirror&gt;&gt;} mirrorMap * @param {BucketsRouter~getMirroringTokensCallback} */ BucketsRouter.prototype.getMirroringTokens = function (mirrorMap, next) { var self = this; async.mapSeries(mirrorMap, function (mirrorList, done) { async.map(mirrorList, self.getMirrorAuthorization.bind(self), done); }, next); }; /** * @callback BucketsRouter~getMirroringTokensCallback * @param {Error|null} error * @param {Array[]} tokenMap * @param {Mirror} tokenMap.mirror * @param {DataChannelPointer} tokenMap.source * @param {Contact} tokenMap.destination */ /** * Establishes mirrors for a given token map * @param {Array[]} tokenMap * @param {BucketsRouter~createMirrorsFromTokenMapCallback} */ BucketsRouter.prototype.createMirrorsFromTokenMap = function (tokenMap, next) { var self = this; async.mapSeries(tokenMap, function (tokenList, done) { if (!tokenList.length) { return done(null, []); } var sources = [], destinations = []; var hash = tokenList[0].mirror.shardHash; self.contracts.load(hash, function (err, item) { if (err) { return done(err); } async.each(tokenList, function (mirrorData, next) { sources.push(mirrorData.source); destinations.push(mirrorData.destination); item.addContract( mirrorData.destination, storj.Contract.fromObject(mirrorData.mirror.contract) ); mirrorData.mirror.isEstablished = true; mirrorData.mirror.save(next); }, function (err) { if (err) { return next(new errors.InternalError(err.message)); } self.contracts.save(item, function (err) { if (err) { return done(err); } self.network.getMirrorNodes(sources, destinations, done); }); }); }); }, next); }; /** * @callback BucketsRouter~createMirrorsFromTokenMapCallback * @param {Error|null} error * @param {Array.&lt;Array.&lt;Contact&gt;&gt;} mirroredNodes */ /** * Lists all the established mirrors for a file * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.listMirrorsForFile = function (req, res, next) { const self = this; function _getFrameForFile(fileId, bucket, callback) { self.storage.models.BucketEntry.findOne({ bucket: bucket.id, _id: fileId }).populate('frame').exec(function (err, bucketEntry) { if (err) { return next(err); } if (!bucketEntry) { return next(new errors.NotFoundError('File not found')); } callback(null, bucketEntry.frame); }); } function _getHashesFromFrame(frame, callback) { self.storage.models.Pointer.find({ _id: { $in: frame.shards } }, function (err, pointers) { if (err) { return next(err); } callback(null, pointers.map((p) =&gt; p.hash)); }); } function _getMirrorsFromHashes(hashes, callback) { async.map(hashes, function (hash, next) { self.storage.models.Shard.findOne({ hash: hash }).exec((err, shard) =&gt; { if (err) { return next(err); } let result = { established: [], available: [] }; let { established } = result; if (!shard) { return next(null, result); } // NOTE: Available is no longer used here as available // mirrors are stored in TTL collection. The contact field // will also not be populated, the farmer_id will be included // if there are additional details needed. for (let i = 0; i &lt; shard.contracts.length; i++) { let contract = shard.contracts[i].contract; established.push({ shardHash: shard.hash, contract: { farmer_id: contract.farmer_id, data_size: contract.data_size, store_begin: contract.store_begin, store_end: contract.store_end } }); } next(null, result); }); }, callback); } async.waterfall([ this._getBucketById.bind(this, req.params.id, req.user._id), _getFrameForFile.bind(this, req.params.file), _getHashesFromFrame, _getMirrorsFromHashes ], (err, result) =&gt; { if (err) { return next(err); } res.status(200).send(result); }); }; /** * Fetches a RETRIEVE token from a farmer for the given shard * @private * @param {Pointer} shardPointer - Pointer document to retrieve * @param {Object} options * @param {Array} options.excludeFarmers - Blacklist array of Node IDs * @param {BucketsRouter~_getRetrievalTokenCallback} */ BucketsRouter.prototype._getRetrievalToken = function (sPointer, opts, done) { const self = this; log.debug('getting retrieval token for %j', sPointer); this.contracts.load(sPointer.hash, function (err, item) { if (err) { return done(err); } let farmers = Object.keys(item.contracts).filter(function (nodeID) { return opts.excludeFarmers.indexOf(nodeID) === -1; }); self.storage.models.Contact.find({ _id: { $in: farmers } }, (err, contacts) =&gt; { if (err) { return done(err); } let currentTime = Date.now(); let finalHandlerAlreadyCalled = false; let { farmerTimeoutIgnore } = self.config.application; let farmerTimeoutMs = ms(farmerTimeoutIgnore || '10m'); let options = contacts .filter((c) =&gt; { if (!c.lastTimeout || c.lastSeen &gt; c.lastTimeout) { return true; } return currentTime - c.lastTimeout &gt; farmerTimeoutMs; }) .sort((a, b) =&gt; b.lastSeen - a.lastSeen) .map((c) =&gt; ({ contact: storj.Contact(c), pointer: null })); let retrievalTimeout = setTimeout(() =&gt; { handleResults( new errors.ServiceUnavailableError('Timed out waiting for pointers') ); finalHandlerAlreadyCalled = true; }, 20000); function handleResults(err, result) { if (finalHandlerAlreadyCalled) { return; } finalHandlerAlreadyCalled = true; clearTimeout(retrievalTimeout); let data = { index: sPointer.index, hash: sPointer.hash, size: sPointer.size, parity: sPointer.parity }; // We want to return the result even if there was a failure // to retrieve the token from the farmer, it will just be missing // a token and farmer contact. if (err || !result) { log.warn( 'Failed to get retrieval token, %s', err ? err.message : 'No farmers responded' ); } else { data.token = result.pointer.token; data.farmer = result.pointer.farmer; data.operation = 'PULL'; } done(null, data); } async.detectLimit( options, 6, self._requestRetrievalPointer.bind(self, item), handleResults ); }); }); }; /** * @callback BucketsRouter~_getRetrievalTokenCallback * @param {Error|null} [error] * @param {Object} dataChannelPointer * @param {String} dataChannelPointer.token * @param {String} dataChannelPointer.hash * @param {Contact} dataChannelPointer.farmer * @param {String} dataChannelPointer.operation * @param {Number} dataChannelPointer.size */ /** * Requests a retrieval pointer from the first farmer in the given list * @private * @param {StorageItem} item - Loaded storage item data * @param {Object} opts * @param {Contact} opts.contact * @param {Pointer|null} opts.pointer * @param {BucketsRouter~_requestRetrievalPointerCallback} */ BucketsRouter.prototype._requestRetrievalPointer = function (item, meta, done) { const network = this.network; const contract = item.getContract(meta.contact); network.getRetrievalPointer(meta.contact, contract, function (err, dcPointer) { if (err) { log.error(err.message); return done(null, false); } if (!dcPointer.token) { log.error('Failed to get a retrieval token from farmer'); return done(); } meta.pointer = { token: dcPointer.token, farmer: meta.contact }; done(null, true); }); }; /** * @callback BucketsRouter~_requestRetrievalPointerCallback * @param {Error|null} [error] * @param {Object} [dataChannelPointer] * @param {String} [dataChannelPointer.token] * @param {String} [dataChannelPointer.hash] * @param {Contact} [dataChannelPointer.farmer] * @param {String} [dataChannelPointer.operation] */ /** * Resolves shard pointer from a populated bucket entry * @private * @param {BucketEntry} entry - Populated bucket entry * @param {Object} options * @param {Number} options.skip - Skip returned entries * @param {Number} options.limit - Limit returned entries * @param {String[]} options.excludeFarmers - Blackisted NodeIDs * @param {BucketsRouter~_getPointersFromEntryCallback} */ BucketsRouter.prototype._getPointersFromEntry = function (entry, opts, user, done) { const self = this; const StorageEvent = this.storage.models.StorageEvent; const Pointer = this.storage.models.Pointer; let pQuery = { _id: { $in: entry.frame.shards }, index: { $gte: parseInt(opts.skip) || 0, $lt: parseInt(opts.skip) + parseInt(opts.limit) || 6 } }; let pSort = { index: 1 }; let cursor = Pointer.find(pQuery).sort(pSort); cursor.exec(function (err, pointers) { if (err) { return done(new errors.InternalError(err.message)); } const bytes = pointers.reduce((a, b) =&gt; { return { size: a.size + b.size }; }, { size: 0 }).size; if (!Number.isFinite(bytes)) { log.warn('getPointersFromEntry: sum bytes %s is not a finite number ' + 'for frame %s', bytes, entry.frame._id); return done(new errors.InternalError( 'Pointer size in not a finite number')); } user.recordDownloadBytes(bytes, (err) =&gt; { if (err) { log.warn('getPointersFromEntry: unable to update downloaded bytes %s', bytes); } }); var fileDownloadStorageEventData = { bucket: entry.bucket, bucketEntry: entry._id, user: user._id, downloadBandwidth: bytes, storage: 0 }; var fileDownloadStorageEvent = new StorageEvent(fileDownloadStorageEventData); fileDownloadStorageEvent.save(function (err) { if (err) { log.warn('createEntryFromFrame: failed to save storage event, reason: %s', err.message); } }); async.mapLimit(pointers, 6, function (sPointer, next) { self._getRetrievalToken(sPointer, { excludeFarmers: opts.excludeFarmers }, next); }, function (err, results) { if (err) { return done(new errors.InternalError(err.message)); } done(null, results); }); }); }; /** * @callback BucketsRouter~_getPointersFromEntryCallback * @param {Error|null} [error] * @param {Object[]} pointers */ /** * Negotiates retrieval tokens from the farmers storing the shards * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.getFile = function (req, res, next) { const self = this; const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; const User = this.storage.models.User; const query = { _id: req.params.id }; if (req.user) { query.user = req.user._id; } else { if (req.params.id !== req.token.bucket.toString()) { return next(new errors.NotAuthorizedError()); } } Bucket.findOne(query, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } User.findOne({ _id: bucket.user }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found for bucket')); } const rates = self.config.application.freeTier.down; if (user.isDownloadRateLimited(rates.hourlyBytes, rates.dailyBytes, rates.monthlyBytes)) { log.warn('getFile: Transfer rate limited, user: %s', user.email); analytics.track(req.headers.dnt, { userId: user.uuid, event: 'User Download Rate Limited', properties: { monthlyBytes: user.bytesDownloaded.lastMonthBytes, dailyBytes: user.bytesDownloaded.lastDayBytes, hourlyBytes: user.bytesDownloaded.lastHourBytes } }); return next(new errors.TransferRateError( 'Could not get file, transfer rate limit reached.' )); } analytics.track(req.headers.dnt, { userId: user.uuid, event: 'File Pointers Retrieved' }); BucketEntry.findOne({ _id: req.params.file, bucket: bucket._id }).populate('frame').exec(function (err, entry) { if (err) { return next(new errors.InternalError(err.message)); } if (!entry) { return next(new errors.NotFoundError('File not found')); } self._getPointersFromEntry(entry, { skip: req.query.skip, limit: req.query.limit, excludeFarmers: req.query.exclude ? req.query.exclude.split(',') : [] }, user, function (err, result) { if (err) { return next(err); } res.send(result); }); }); }); }); }; /** * Lists the file pointers stored in the given bucket * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.listFilesInBucket = function (req, res, next) { const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; Bucket.findOne({ _id: req.params.id, user: req.user._id }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } const startDate = utils.parseTimestamp(req.query.startDate); const findQuery = { bucket: req.params.id }; if (startDate) { findQuery.created = { $gt: startDate }; } var query = BucketEntry .find(findQuery) .sort({ created: 1 }) .limit(constants.DEFAULT_MAX_ENTRIES) .populate('frame'); var stream = query.cursor(); stream.pipe(utils.createArrayFormatter(function (entry) { return { bucket: entry.bucket, mimetype: entry.mimetype, filename: entry.filename, frame: entry.frame.id, size: entry.frame.size, id: entry._id, created: entry.created, hmac: entry.hmac, erasure: entry.erasure, index: entry.index }; })).pipe(res); }); }; /** * Removes the file pointer from the bucket * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ BucketsRouter.prototype.removeFile = function (req, res, next) { const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; const StorageEvent = this.storage.models.StorageEvent; Bucket.findOne({ _id: req.params.id, user: req.user._id }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } BucketEntry.findOne({ bucket: bucket._id, _id: req.params.file }).populate('frame').exec(function (err, entry) { if (err) { return next(err); } if (!entry) { return next(new errors.NotFoundError('File not found')); } entry.remove(function (err) { if (err) { return next(new errors.InternalError(err.message)); } var fileRemovalEventData = { bucket: req.params.id, bucketEntry: req.params.file, user: req.user._id, downloadBandwidth: 0, storage: -1 * entry.frame.size }; var fileRemovalStorageEvent = new StorageEvent(fileRemovalEventData); fileRemovalStorageEvent.save(function (err) { if (err) { log.warn('createEntryFromFrame: failed to save storage event, reason: %s', err.message); } }); res.status(204).end(); }); }); }); }; BucketsRouter.prototype.getFileId = function (req, res, next) { const Bucket = this.storage.models.Bucket; const BucketEntry = this.storage.models.BucketEntry; Bucket.findOne({ _id: req.params.id, user: req.user._id }, '_id', { lean: true }, function (err, bucket) { if (err) { return next(new errors.InternalError(err.message)); } if (!bucket) { return next(new errors.NotFoundError('Bucket not found')); } BucketEntry.findOne({ bucket: bucket._id, name: req.params.name }, '_id', { lean: true }, function (err, entry) { if (err) { return next(new errors.InternalError(err.message)); } if (!entry) { return next(new errors.NotFoundError('File not found')); } res.status(200).send({ id: entry._id }); }); }); }; BucketsRouter.prototype.getFileInfo = function (req, res, next) { const BucketEntry = this.storage.models.BucketEntry; this._getBucketUnregistered(req, res, function (err, bucket) { if (err) { return next(err); } BucketEntry.findOne({ bucket: bucket._id, _id: req.params.file }).populate('frame').exec(function (err, entry) { if (err) { return next(new errors.InternalError(err.message)); } if (!entry) { return next(new errors.NotFoundError('File not found')); } res.status(200).send({ bucket: entry.bucket, mimetype: entry.mimetype, filename: entry.filename, frame: entry.frame.id, size: entry.frame.size, id: entry._id, created: entry.created, hmac: entry.hmac, erasure: entry.erasure, index: entry.index }); }); }); }; BucketsRouter.prototype.getStorageUsage = function (req, res, next) { const Bucket = this.storage.models.Bucket; var agg = Bucket.aggregate([ { $match: { user: req.user._id } }, { $lookup: { from: 'bucketentries', localField: '_id', foreignField: 'bucket', as: 'join1' } }, { $unwind: { path: '$join1' } }, { $lookup: { from: \"frames\", localField: \"join1.frame\", foreignField: \"_id\", as: \"join2\" } }, { $unwind: { path: '$join2' } }, { $project: { _id: '$join2._id', user: '$join2.user', size: '$join2.size' } }, { $group: { _id: '$user', total: { $sum: '$size' } } } ]).cursor({ batchSize: 1000 }).exec(); agg.next().then(data =&gt; { res.status(200).send(data); }).catch(err =&gt; { res.status(400).send({ message: 'Error' }); }); } /** * Export definitions * @private */ BucketsRouter.prototype._definitions = function () { /* jshint maxlen: 140 */ return [ ['GET', '/buckets', this.getLimiter(limiter(1000)), this._verify, this.getBuckets], ['GET', '/buckets/:id', this.getLimiter(limiter(1000)), this._validate, this._verify, this.getBucketById], ['GET', '/bucket-ids/:name', this.getLimiter(limiter(1000)), this._validate, this._verify, this.getBucketId], ['POST', '/buckets', this.getLimiter(limiter(1000)), this._verify, this.createBucket], ['DELETE', '/buckets/:id', this.getLimiter(limiter(1000)), this._validate, this._verify, this.destroyBucketById], ['PATCH', '/buckets/:id', this.getLimiter(limiter(1000)), this._validate, this._verify, this.updateBucketById], ['POST', '/buckets/:id/tokens', this.getLimiter(limiter(1000)), this._validate, this._verify, this.createBucketToken], ['GET', '/buckets/:id/files', this.getLimiter(limiter(1000)), this._validate, this._verify, this.listFilesInBucket], ['GET', '/buckets/:id/file-ids/:name', this.getLimiter(limiter(1000)), this._validate, this._verify, this.getFileId], ['GET', '/buckets/:id/files/:file', this.getLimiter(limiter(1000)), this._validate, this._usetokenOrVerify, this.getFile], ['DELETE', '/buckets/:id/files/:file', this.getLimiter(limiter(1000)), this._validate, this._verify, this.removeFile], ['GET', '/buckets/:id/files/:file/info', this.getLimiter(limiter(1000)), this._validate, this.getFileInfo], ['POST', '/buckets/:id/files', this.getLimiter(limiter(1000)), this._validate, this._verify, this.createEntryFromFrame], ['GET', '/buckets/:id/files/:file/mirrors', this.getLimiter(limiter(1000)), this._validate, this._verify, this.listMirrorsForFile], ['GET', '/usage', this.getLimiter(limiter(1000)), this._verify, this.getStorageUsage] ]; }; module.exports = BucketsRouter; × Search results Close "},"lib_server_routes_index.js.html":{"id":"lib_server_routes_index.js.html","title":"Source: lib/server/routes/index.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/index.js 'use strict'; /** * Abstract representation of a route series * @constructor * @param {Object} options * @param {Config} options.config * @param {complex.Client} options.network * @param {Storage} options.storage * @param {Mailer} options.mailer */ function Router(options) { if (!(this instanceof Router)) { return new Router(options); } this.config = options.config; this.network = options.network; this.storage = options.storage; this.mailer = options.mailer; this.contracts = options.contracts; this.redis = options.redis; } /** * Returns the result of the private _definitions method * @returns {Array} */ Router.prototype.getEndpointDefinitions = function() { var self = this; return this._definitions().map(function(def) { return def.map(function(val) { if (typeof val === 'function') { return val.bind(self); } else { return val; } }); }); }; module.exports = Router; × Search results Close "},"lib_cleaner_index.js.html":{"id":"lib_cleaner_index.js.html","title":"Source: lib/cleaner/index.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/cleaner/index.js 'use strict'; const async = require('async'); const assert = require('assert'); const crypto = require('crypto'); const storj = require('storj-lib'); const CleanerConfig = require('./config'); const Storage = require('storj-service-storage-models'); const ComplexClient = require('storj-complex').createClient; const MongoDBStorageAdapter = require('storj-mongodb-adapter'); const ms = require('ms'); const log = require('../logger'); const errors = require('storj-service-error-types'); /** * A long running daemon that will inspect database looking for orphan * documents and perform a clean up. * It can be performed once a day. * @param {CleanerConfig} config - An instance of CleanerConfig */ function Cleaner(config) { if (!(this instanceof Cleaner)) { return new Cleaner(config); } assert(config instanceof CleanerConfig, 'Invalid config supplied'); this.storage = null; this.network = null; this.contracts = null; this._config = config; this._timeout = null; this._running = false; this._underAttack = false; } /** * Starts the Bridge instance * @param {Function} callback */ Cleaner.prototype.start = function (callback) { log.info('Cleaner service is starting'); this.storage = new Storage( this._config.storage.mongoUrl, this._config.storage.mongoOpts, { logger: log } ); this.network = new ComplexClient(this._config.complex); this.contracts = new storj.StorageManager( new MongoDBStorageAdapter(this.storage), { disableReaper: true } ); // setup next run event this.wait(); callback(); process.on('SIGINT', this._handleSIGINT.bind(this)); process.on('exit', this._handleExit.bind(this)); process.on('uncaughtException', this._handleUncaughtException.bind(this)); }; Cleaner.sortByTimeoutRate = function (a, b) { const a1 = a.contact.timeoutRate &gt;= 0 ? a.contact.timeoutRate : 0; const b1 = b.contact.timeoutRate &gt;= 0 ? b.contact.timeoutRate : 0; return (a1 === b1) ? 0 : (a1 &gt; b1) ? 1 : -1; }; Monitor.prototype.run = function () { // If a check round is being executed, wait. if (this._running) { return this.wait(); } const limit = this._config.application.queryNumber || 10; const finish = (err) =&gt; { if (err) { log.error(err); } log.info('Ending cleaner round with failure rate of %s/%s from %s', fail, success, total); this._running = false; this.wait(); }; log.info('Starting clean up round'); this._running = true; // Query the least seen contacts with timeout rates below threshold // Look for shards below the required number of mirrors const Contact = this.storage.models.Contact; const query = { $or: [ { timeoutRate: { $lt: timeoutRateThreshold } }, { timeoutRate: { $exists: false } } ] }; return; const cursor = Contact.find(query).limit(limit).sort({ lastSeen: 1 }); cursor.exec((err, contacts) =&gt; { if (err) { return finish(err); } if (!contacts) { return finish( new errors.InternalError('No contacts in contacts collection') ); } // Update total length of contacts total = contacts.length; console.log(\"Total farmers found to scan: %s\", total); // Ping the least seen contacts async.eachLimit(contacts, pingConcurrency, (contactData, next) =&gt; { const contact = storj.Contact(contactData); this.network.ping(contact, (err) =&gt; { if (err) { fail += 1; log.error('Farmer %s failed ping, reason: %s', contact.nodeID, err.message); contactData.recordTimeoutFailure().save((err) =&gt; { if (err) { log.error('Unable to save ping failure, farmer: %s, reason: %s', contact.nodeID, err.message); } }); if (contactData.timeoutRate &gt;= timeoutRateThreshold) { log.warn('Shards from farmer %s must be replicated, timeoutRate: %s', contact.nodeID, contactData.timeoutRate); this._replicateFarmer(contact); } } else { success += 1; } next(); }); }, finish); }); }; Monitor.prototype._randomTime = function (max, min) { const range = max - min; assert(Number.isSafeInteger(range)); assert(range &gt; 0, 'maxInterval is expected to be greater than minInterval'); const entropy = crypto.randomBytes(8).toString('hex'); const offset = Math.round(parseInt('0x' + entropy) / Math.pow(2, 64) * range); return min + offset; }; /** * Will wait and then call `run` after a random amount of time */ Cleaner.prototype.wait = function () { clearTimeout(this._timeout); const max = ms(this._config.application.maxInterval); const min = ms(this._config.application.minInterval); const milliseconds = this._randomTime(max, min); const minutes = Number(milliseconds / 1000 / 60).toFixed(2); log.info('Scheduling next round in %s minutes', minutes); this._timeout = setTimeout(() =&gt; this.run(), milliseconds); }; /** * Handles uncaught exceptions * @private */ /* istanbul ignore next */ Cleaner.prototype._handleUncaughtException = function (err) { if (process.env.NODE_ENV === 'test') { throw err; } log.error('An unhandled exception occurred:', err); process.exit(1); }; /** * Handles exit event from process * @private */ /* istanbul ignore next */ Cleaner.prototype._handleExit = function () { log.info('Cleaner service is shutting down'); }; /** * Postpones process exit until requests are fullfilled * @private */ /* istanbul ignore next */ Cleaner.prototype._handleSIGINT = function () { let waitTime = 0; log.info('Received shutdown signal, checking for running cleaner'); setInterval(function () { waitTime += Cleaner.SIGINT_CHECK_INTERVAL; if (!this._running) { process.exit(); } if (waitTime &gt; Cleaner.MAX_SIGINT_WAIT) { process.exit(); } }, Cleaner.SIGINT_CHECK_INTERVAL); }; module.exports = Cleaner; × Search results Close "},"lib_config.js.html":{"id":"lib_config.js.html","title":"Source: lib/config.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/config.js 'use strict'; const assert = require('assert'); const os = require('os'); const rc = require('rc'); const fs = require('fs'); const path = require('path'); const merge = require('merge'); const ENV = process.env; const PLATFORM = os.platform(); const DIRNAME = '.storj-bridge'; const HOME = PLATFORM === 'win32' ? ENV.USERPROFILE : ENV.HOME; const STORJ_BRIDGE_PATH = ENV.STORJ_BRIDGE_DIR || HOME; const DATADIR = path.join(STORJ_BRIDGE_PATH, DIRNAME); const CONSTANTS = require('./constants'); const utils = require('./utils'); const DEFAULTS = { storage: { mongoUrl: `mongodb://127.0.0.1:27017/__storj-bridge-${process.env.NODE_ENV || 'develop'}`, mongoOpts: {} }, server: { host: '127.0.0.1', port: 6382, timeout: 240000, ssl: { cert: null, key: null, ca: [], redirect: 80 }, public: { host: '127.0.0.1', port: 80 }, corsRegex: '^https?://(\\\\w{1,63}\\\\.){0,6}?storj\\\\.io$' }, complex: { rpcUrl: 'http://localhost:8080', rpcUser: 'user', rpcPassword: 'pass' }, logger: { level: CONSTANTS.LOG_LEVEL_INFO }, mailer: { host: '127.0.0.1', port: 465, secure: true, auth: { user: 'username', pass: 'password' }, from: 'robot@storj.io' }, application: { delayedActivation: true, // send delayed user activation email activateSIP6: false, powOpts: { retargetPeriod: 10000, // milliseconds retargetCount: 10, // per retargetPeriod }, publishBenchThreshold: 2500, // reputation publishTotal: 36, // number of farmers to publish in active pool publishBenchTotal: 9, // number of farmers to publish in bench pool shardsPerMinute: 1000, farmerTimeoutIgnore: '10m', freeTier: { up: { hourlyBytes: 3000000000, dailyBytes: 10000000000, monthlyBytes: 60000000000 }, down: { hourlyBytes: 9000000000, dailyBytes: 30000000000, monthlyBytes: 180000000000 } } }, redis: { host: 'localhost', port: 6379 } }; function getPaths(env, confpath, datadir) { var paths = {}; if (datadir) { assert(path.isAbsolute(datadir), 'datadir is expected to be absolute'); paths.datadir = datadir; } else { paths.datadir = DATADIR; } if (confpath) { assert(path.isAbsolute(confpath), 'confpath is expected to be absolute'); paths.confdir = path.dirname(confpath); paths.confpath = confpath; } else { paths.confdir = path.join(paths.datadir, 'config'); assert(env, 'env is expected without config path'); paths.confpath = path.join(paths.confdir, env); } return paths; } function setupConfig(paths) { if (!fs.existsSync(paths.confdir)) { fs.mkdirSync(paths.confdir); } if (!fs.existsSync(paths.confpath)) { fs.writeFileSync(paths.confpath, JSON.stringify(DEFAULTS, null, 2)); } } function setupDataDirectory(paths) { if (!fs.existsSync(paths.datadir)) { fs.mkdirSync(paths.datadir); } var itemdir = path.join(paths.datadir, 'items'); if (!fs.existsSync(itemdir)) { fs.mkdirSync(itemdir); } } /** * Represents a configuration * @constructor * @param {String|Object} arg */ function Config(env, confpath, datadir) { if (!(this instanceof Config)) { return new Config(env, confpath, datadir); } let config; if (typeof env === 'string') { var paths = Config.getPaths(env, confpath, datadir); Config.setupDataDirectory(paths); Config.setupConfig(paths); config = merge.recursive( JSON.parse(JSON.stringify(DEFAULTS)), JSON.parse(fs.readFileSync(paths.confpath)) ); } else { config = merge.recursive( JSON.parse(JSON.stringify(DEFAULTS)), env ); } config = rc('storjbridge', config); for (let prop in config) { this[prop] = utils.recursiveExpandJSON(config[prop]); } } Config.DEFAULTS = DEFAULTS; Config.setupDataDirectory = setupDataDirectory; Config.setupConfig = setupConfig; Config.getPaths = getPaths; module.exports = Config; × Search results Close "},"lib_monitor_config.js.html":{"id":"lib_monitor_config.js.html","title":"Source: lib/monitor/config.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/monitor/config.js 'use strict'; const assert = require('assert'); const fs = require('fs'); const rc = require('rc'); const path = require('path'); const merge = require('merge'); const CONSTANTS = require('../constants'); const utils = require('../utils'); const DEFAULT_DB = process.env.NODE_ENV || 'develop'; const DEFAULTS = { storage: { mongoUrl: `mongodb://127.0.0.1:27017/__storj-bridge-${DEFAULT_DB}`, mongoOpts: {} }, complex: { rpcUrl: 'http://localhost:8080', rpcUser: 'user', rpcPassword: 'pass' }, logger: { level: CONSTANTS.LOG_LEVEL_INFO }, application: { maxInterval: '10m', minInterval: '5m', queryNumber: 100, pingConcurrency: 10, timeoutRateThreshold: 0.04 // ~1 hour of downtime in 24 hours } }; function getPaths(confpath) { var paths = {}; assert(path.isAbsolute(confpath), 'confpath is expected to be absolute'); paths.confdir = path.dirname(confpath); paths.confpath = confpath; return paths; } function setupConfig(paths) { if (!fs.existsSync(paths.confdir)) { fs.mkdirSync(paths.confdir); } if (!fs.existsSync(paths.confpath)) { fs.writeFileSync(paths.confpath, JSON.stringify(DEFAULTS, null, 2)); } } /** * Represents a configuration * @constructor * @param {String|Object} arg */ function Config(confpath) { if (!(this instanceof Config)) { return new Config(confpath); } let fileConfig = {}; if (confpath) { const paths = Config.getPaths(confpath); Config.setupConfig(paths); fileConfig = JSON.parse(fs.readFileSync(paths.confpath)); } let config = merge.recursive( JSON.parse(JSON.stringify(DEFAULTS)), fileConfig ); config = rc('storjmonitor', config); for (let prop in config) { this[prop] = utils.recursiveExpandJSON(config[prop]); } } Config.DEFAULTS = DEFAULTS; Config.setupConfig = setupConfig; Config.getPaths = getPaths; module.exports = Config; × Search results Close "},"lib_server_routes_contacts.js.html":{"id":"lib_server_routes_contacts.js.html","title":"Source: lib/server/routes/contacts.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/contacts.js 'use strict'; const Router = require('./index'); const dns = require('dns'); const isIp = require('is-ip'); const errors = require('storj-service-error-types'); const inherits = require('util').inherits; const middleware = require('storj-service-middleware'); const log = require('../../logger'); const limiter = require('../limiter').DEFAULTS; const rawBody = require('../middleware/raw-body'); const {getPOWMiddleware, getChallenge} = require('../middleware/pow'); const {authFarmer} = require('../middleware/farmer-auth'); /** * Handles endpoints for all contact related endpoints * @constructor * @extends {Router} */ function ContactsRouter(options) { if (!(this instanceof ContactsRouter)) { return new ContactsRouter(options); } Router.apply(this, arguments); this.redis = options.redis; this.checkPOW = getPOWMiddleware(options.redis); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(ContactsRouter, Router); ContactsRouter.DEFAULTS = { skip: 0, limit: 30 }; /** * Returns the correct skip and limit from the supplied page number * @private */ ContactsRouter.prototype._getSkipLimitFromPage = function(page) { page = page || 1; return { limit: ContactsRouter.DEFAULTS.limit, skip: (page - 1) * ContactsRouter.DEFAULTS.limit }; }; ContactsRouter.prototype.createChallenge = function(req, res, next) { let powOpts = this.config.application.powOpts; getChallenge(this.redis, powOpts, function(err, data) { if (err) { return next(new errors.InternalError(err.message)); } res.status(201).send(data); }); }; ContactsRouter.prototype.createContact = function(req, res, next) { const Contact = this.storage.models.Contact; Contact.record({ nodeID: req.headers['x-node-id'], address: req.body.address, port: req.body.port, lastSeen: Date.now(), spaceAvailable: req.body.spaceAvailable, responseTime: 10000, // Need to set a default responseTime for new contacts reputation: 0, // Set default reputation for new contacts as well protocol: req.body.protocol, ip: this._getContactIP(req.body.address) }, function(err, contact) { if (err) { return next(new errors.InternalError(err.message)); } // TODO Send 201 status when created, and 200 when it already // exists. Multiple calls to record should behave the same, // as is current. res.status(200).send({ nodeID: contact.nodeID, address: contact.address, port: contact.port }); }); }; ContactsRouter.prototype._getContactIP = function(addr) { if (isIp(addr)) { return addr; } else { dns.resolve4(addr, function (err, addresses) { if (err) { log.warn('getIPLookup: Could not resolve address: %s', addr); return null; } log.debug('getIPLookup: Resolved address: %s to %s', addr, addresses[0]); return addresses[0]; }); } }; ContactsRouter.prototype.setDefaultResponseTime = function(nodeID) { this.storage.models.Contact.findOneAndUpdate({ _id: nodeID, responseTime: { $exists: false } }, { $set: { responseTime: 10000 } }, { upsert: false }, (err) =&gt; { if (err) { log.error('Error setting default responseTime for %s, reason: %s', nodeID, err.message); } }); }; ContactsRouter.prototype.setDefaultReputation = function(nodeID) { this.storage.models.Contact.findOneAndUpdate({ _id: nodeID, reputation: { $exists: false } }, { $set: { reputation: 0 } }, { upsert: false }, (err) =&gt; { if (err) { log.error('Error setting default reputation for %s, reason: %s', nodeID, err.message); } }); }; ContactsRouter.prototype.patchContactByNodeID = function(req, res, next) { const Contact = this.storage.models.Contact; const nodeID = req.headers['x-node-id']; const data = { lastSeen: Date.now() }; if (req.body.address) { data.address = req.body.address; data.ip = this._getContactIP(req.body.address); } if (req.body.port) { data.port = req.body.port; } if (req.body.protocol) { data.protocol = req.body.protocol; } if (req.body.spaceAvailable === false || req.body.spaceAvailable === true) { data.spaceAvailable = req.body.spaceAvailable; } Contact.findOneAndUpdate({ _id: nodeID }, { $set: data }, { upsert: false, returnNewDocument: true }, (err, contact) =&gt; { if (err) { return next(new errors.InternalError(err.message)); } if (!contact) { return next(new errors.NotFoundError('Contact not found')); } if (!contact.responseTime) { this.setDefaultResponseTime(nodeID); } if (!contact.reputation) { this.setDefaultReputation(nodeID); } res.status(201).send({ nodeID: contact.nodeID, address: contact.address, port: contact.port, spaceAvailable: contact.spaceAvailable }); }); }; /** * Lists the contacts according the the supplied query * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ ContactsRouter.prototype.getContactList = function(req, res, next) { const Contact = this.storage.models.Contact; let allowedQueryParams = ['address']; let opts = this._getSkipLimitFromPage(req.query.page); let skip = opts.skip; let limit = opts.limit; let query = {}; for (let param in req.query) { if (allowedQueryParams.indexOf(param) !== -1) { query[param] = req.query[param]; } } let cursor = Contact.find(query).skip(skip).limit(limit).sort({ lastSeen: -1 }); cursor.exec(function(err, contacts) { if (err) { return next(new errors.InternalError(err.message)); } res.status(200).send(contacts.sort(function(c1, c2) { return c2.lastSeen - c1.lastSeen; }).map(function(c) { return c.toObject(); })); }); }; /** * Returns the contact information for the given nodeID * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ ContactsRouter.prototype.getContactByNodeID = function(req, res, next) { const Contact = this.storage.models.Contact; Contact.findOne({ _id: req.params.nodeID }, function(err, contact) { if (err) { return next(new errors.InternalError(err.message)); } if (!contact) { return next(new errors.NotFoundError('Contact not found')); } res.status(200).send(contact.toObject()); }); }; /** * Export definitions * @private */ ContactsRouter.prototype._definitions = function() { return [ ['GET', '/contacts', this.getLimiter(limiter(200)), this.getContactList], ['GET', '/contacts/:nodeID', this.getLimiter(limiter(200)), this.getContactByNodeID], ['PATCH', '/contacts/:nodeID', this.getLimiter(limiter(200)), rawBody, authFarmer, this.patchContactByNodeID], ['POST', '/contacts', this.getLimiter(limiter(200)), this.checkPOW, rawBody, authFarmer, this.createContact], ['POST', '/contacts/challenges', this.getLimiter(limiter(200)), rawBody, authFarmer, this.createChallenge] ]; }; module.exports = ContactsRouter; × Search results Close "},"lib_engine.js.html":{"id":"lib_engine.js.html","title":"Source: lib/engine.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/engine.js 'use strict'; const v8 = require('v8'); const hat = require('hat'); const async = require('async'); const storj = require('storj-lib'); const assert = require('assert'); const express = require('express'); const crossorigin = require('cors'); const helmet = require('helmet'); const pkginfo = require('../package'); const Config = require('./config'); const Storage = require('storj-service-storage-models'); const middleware = require('storj-service-middleware'); const Server = require('./server'); const pow = require('./server/middleware/pow'); const Mailer = require('storj-service-mailer'); const log = require('./logger'); const ComplexClient = require('storj-complex').createClient; const MongoDBStorageAdapter = require('storj-mongodb-adapter'); /** * Primary interface to Bridge (the glue) * @constructor * @param {Config} config */ function Engine(config) { if (!(this instanceof Engine)) { return new Engine(config); } assert(config instanceof Config, 'Invalid config supplied'); this._config = config; this._apispec = null; this._pendingResponses = {}; this._cpuUsage = process.cpuUsage(); this._healthInterval = null; } Engine.SIGINT_CHECK_INTERVAL = 1000; Engine.MAX_SIGINT_WAIT = 5000; Engine.RESPONSE_CLEAN_INTERVAL = 5000; Engine.HEALTH_INTERVAL = 30000; /** * Starts the Bridge instance * @param {Function} callback */ Engine.prototype.start = function(callback) { log.info('starting the bridge engine'); this.storage = new Storage( this._config.storage.mongoUrl, this._config.storage.mongoOpts, { logger: log } ); this.mailer = new Mailer(this._config.mailer); this.network = new ComplexClient(this._config.complex); this.contracts = new storj.StorageManager( new MongoDBStorageAdapter(this.storage), { disableReaper: true } ); this.redis = require('redis').createClient(this._config.redis); this.redis.on('ready', () =&gt; { log.info('connected to redis'); pow.checkInitTarget(this.redis, (err) =&gt; { if (err) { log.error('unable to initialize pow settings', err); } }); }); this.redis.on('error', (err) =&gt; { log.error('error connecting to redis', err); }); this.server = new Server(this._config.server, this._configureApp()); this._healthInterval = setInterval(() =&gt; this._logHealthInfo(), Engine.HEALTH_INTERVAL); callback(); process.on('SIGINT', this._handleSIGINT.bind(this)); process.on('exit', this._handleExit.bind(this)); process.on('uncaughtException', this._handleUncaughtException.bind(this)); }; /** * Handles uncaught exceptions * @private */ /* istanbul ignore next */ Engine.prototype._handleUncaughtException = function(err) { if (process.env.NODE_ENV === 'test') { throw err; } log.error('an unhandled exception occurred: %s', err.stack); process.exit(1); }; /** * Handles exit event from process * @private */ /* istanbul ignore next */ Engine.prototype._handleExit = function() { log.info('bridge service is shutting down'); }; /** * Postpones process exit until requests are fullfilled * @private */ /* istanbul ignore next */ Engine.prototype._handleSIGINT = function() { let self = this; let waitTime = 0; log.info('received shutdown signal, waiting for pending responses'); setInterval(function() { waitTime += Engine.SIGINT_CHECK_INTERVAL; if (Object.keys(self._pendingResponses).length === 0) { process.exit(); } if (waitTime &gt; Engine.MAX_SIGINT_WAIT) { process.exit(); } }, Engine.SIGINT_CHECK_INTERVAL); }; /** * Configures the express app and loads routes * @private */ Engine.prototype._configureApp = function() { log.info('configuring service endpoints'); let self = this; const app = express(); const routers = Server.Routes({ config: this._config, storage: this.storage, network: this.network, mailer: this.mailer, contracts: this.contracts, redis: this.redis }); const corsOptions = { credentials: true, origin: function (origin, next) { const corsRegex = new RegExp(self._config.server.corsRegex); const originAllowed = function () { if (process.env.NODE_ENV !== 'production') { log.warn('Insecure CORS configuration in use; non-production env detected'); return true; } return corsRegex.test(origin); }; next(null, originAllowed()); } }; function bindRoute(route) { let verb = route.shift().toLowerCase(); app[verb].apply(app, route); } self._keepPendingResponsesClean(); app.use(this._trackResponseStatus.bind(this)); app.use(crossorigin(corsOptions)); app.use(helmet()); app.get('/', this._handleRootGET.bind(this)); routers.forEach(bindRoute); app.use(middleware.errorhandler({ logger: log })); return app; }; /** * Responds with the swagger spec * @private */ Engine.prototype._handleRootGET = function(req, res) { res.send(this.getSpecification()); }; /** * Keeps tabs on all of the pending responses * @private */ Engine.prototype._trackResponseStatus = function(req, res, next) { this._pendingResponses[hat()] = [req.socket, res]; next(); }; /** * Clean up the pending request stack * @private */ Engine.prototype._keepPendingResponsesClean = function() { var self = this; setInterval(function() { for (var id in self._pendingResponses) { let [sock, resp] = self._pendingResponses[id]; if (sock.destroyed || resp.finished) { delete self._pendingResponses[id]; } } }, Engine.RESPONSE_CLEAN_INTERVAL); }; /** * Count all current unfinished responses * @private */ Engine.prototype._countPendingResponses = function() { let self = this; let count = 0; for (var id in this._pendingResponses) { let [sock, resp] = self._pendingResponses[id]; if (!(resp.finished || sock.destroyed)) { count++; } else { delete this._pendingResponses[id]; } } return count; }; Engine.prototype._logHealthInfo = function() { async.series({ connections: (next) =&gt; { this.server.server.getConnections(next); } }, (err, results) =&gt; { if (err) { // Error message is included in results below results = {}; } const cpuDiff = process.cpuUsage(this.cpuUsage); this.cpuUsage = process.cpuUsage(); const health = { pid: process.pid, cpuUsage: this.cpuUsage, cpuDiff: cpuDiff, memory: process.memoryUsage(), heapStatistics: v8.getHeapStatistics(), heapSpaceStatistics: v8.getHeapSpaceStatistics(), uptime: process.uptime(), listening: this.server.server.listening, connections: results.connections, pendingResponses: this._countPendingResponses(), databaseState: this.storage.connection.readyState, redisConnected: this.redis.connected }; if (err) { health.error = err.message; } log.info('%j', { bridge_health_report: health }); }); }; /** * Returns a dictionary of info about the service * @returns {Object} */ Engine.prototype.getSpecification = function() { this._apispec = require('./apispec.json'); this._apispec.schemes = this._config.server.ssl.cert ? ['https'] : ['http']; this._apispec.host = this._config.server.host; this._apispec.info = { title: 'Internxt Bridge', version: pkginfo.version, description: pkginfo.description, 'x-protocol-version': storj.version.protocol, 'x-core-version': storj.version.software }; return this._apispec; }; module.exports = Engine; × Search results Close "},"lib_server_routes_frames.js.html":{"id":"lib_server_routes_frames.js.html","title":"Source: lib/server/routes/frames.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/frames.js 'use strict'; const async = require('async'); const storj = require('storj-lib'); const middleware = require('storj-service-middleware'); const crypto = require('crypto'); const authenticate = middleware.authenticate; const errors = require('storj-service-error-types'); const Router = require('./index'); const inherits = require('util').inherits; const ms = require('ms'); const log = require('../../logger'); const constants = require('../../constants'); const { MAX_SHARD_SIZE } = require('storj-service-storage-models').constants; const analytics = require('storj-analytics'); const limiter = require('../limiter').DEFAULTS; const utils = require('../../utils'); /** * Handles endpoints for all frame/file staging related operations * @constructor * @extends {Router} */ function FramesRouter(options) { if (!(this instanceof FramesRouter)) { return new FramesRouter(options); } Router.apply(this, arguments); this._defaults = options.config.application; this._verify = authenticate(this.storage); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(FramesRouter, Router); /** * Creates a file staging frame * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ FramesRouter.prototype.createFrame = async function (req, res, next) { const Frame = this.storage.models.Frame; let spaceLeft = await userHasFreeSpaceLeft(this.storage, req.user.email); if (!spaceLeft.canUpload) { log.warn('User %s exceeded limit, no uploads allowed', req.user.id); return next(new errors.TransferRateError('Max. space used')); } const rates = this.config.application.freeTier.up; if (req.user.isUploadRateLimited(rates.hourlyBytes, rates.dailyBytes, rates.monthlyBytes)) { log.warn('createFrame: Transfer rate limited, user: %s', req.user.email); analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'User Upload Rate Limited', properties: { monthlyBytes: req.user.bytesUploaded.lastMonthBytes, dailyBytes: req.user.bytesUploaded.lastDayBytes, hourlyBytes: req.user.bytesUploaded.lastHourBytes } }); return next(new errors.TransferRateError( 'Could not create frame, transfer rate limit reached.' )); } analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Frame Created' }); Frame.create(req.user, function (err, frame) { if (err) { return next(new errors.InternalError(err.message)); } res.send(frame.toObject()); }); }; /** * Negotiates a contract and updates persistence for the given contract data * @private * @param {storj.Contract} contract - The contract object to publish * @param {storj.AuditStream} audit - The audit object to add to persistence * @param {Array} blacklist - Do not accept offers from these nodeIDs * @param {Object} res - The associated response * @param {Function} callback - Called with error or (farmer, contract) */ FramesRouter.prototype._getContractForShard = function (contr, audit, bl, res, done) { const self = this; const hash = contr.get('data_hash'); self.contracts.load(hash, function (err, item) { if (err) { item = new storj.StorageItem({ hash: hash }); } self.network.getStorageOffer(contr, bl, function (err, farmer, contract) { if (err) { return done(err); } // NB: This can happen even if the client times out and the contract // would be added to the item even though the client never had a chance // to upload the data to the farmer if (res.socket.destroyed) { return; } item.addContract(farmer, contract); item.addAuditRecords(farmer, audit); item.addMetaData(farmer, { downloadCount: 0 }); self.contracts.save(item, function (err) { if (err) { return done(new errors.InternalError(err.message)); } done(null, farmer, contract); }); }); }); }; /** * Negotiates a contract and updates persistence for the given contract data * @private * @param {storj.Contract} contract - The contract object to publish * @param {storj.AuditStream} audit - The audit object to add to persistence * @param {Array} blacklist - Do not accept offers from these nodeIDs * @param {Object} res - The associated response * @param {Function} callback - Called with error or (farmer, contract) */ FramesRouter.prototype._getContractForShardSIP6 = function (contr, audit, bl, res, done) { this._selectFarmers(bl, (err, farmers) =&gt; { if (err) { return done(new errors.InternalError(err.message)); } if (!farmers || !farmers.length) { return done(new errors.InternalError('Could not locate farmers')); } this._publishContract(farmers, contr, audit, (err, farmerContact, farmerContract, token) =&gt; { if (err) { return done(new errors.InternalError(err.message)); } done(null, farmerContact, farmerContract, token); }); }); }; FramesRouter._sortByResponseTime = function (a, b) { const aTime = a.contact.responseTime || Infinity; const bTime = b.contact.responseTime || Infinity; return (aTime === bTime) ? 0 : (aTime &gt; bTime) ? 1 : -1; }; FramesRouter._sortByReputation = function(a, b) { const aVal = a.contact.reputation || Infinity; const bVal = b.contact.reputation || Infinity; return (aVal === bVal) ? 0 : (aVal &gt; bVal) ? 1 : -1; }; FramesRouter.prototype._selectFarmers = function(excluded, callback) { async.parallel([ (next) =&gt; { this.storage.models.Contact.find({ _id: { $lte: crypto.randomBytes(20).toString('hex'), $nin: excluded }, reputation: { $gt: this._defaults.publishBenchThreshold }, spaceAvailable: true }).sort({ _id: -1 }) .limit(this._defaults.publishTotal) .exec(next); }, (next) =&gt; { this.storage.models.Contact.find({ _id: { $lte: crypto.randomBytes(20).toString('hex'), $nin: excluded }, reputation: { $lte: this._defaults.publishBenchThreshold }, spaceAvailable: true }).sort({ _id: -1 }) .limit(this._defaults.publishBenchTotal) .exec(next); } ], (err, results) =&gt; { if (err) { return callback(err); } const combined = results[0].concat(results[1]); callback(null, combined); }); }; FramesRouter.prototype._publishContract = function (nodes, contract, audit, callback) { const hash = contract.get('data_hash'); this.contracts.load(hash, (err, item) =&gt; { if (err) { item = new storj.StorageItem({ hash: hash }); } this.network.publishContract(nodes, contract, (err, data) =&gt; { if (err) { return callback(err); } const farmerContact = storj.Contact(data.contact); const farmerContract = storj.Contract(data.contract); item.addContract(farmerContact, farmerContract); item.addAuditRecords(farmerContact, audit); this.contracts.save(item, (err) =&gt; { if (err) { return callback(new errors.InternalError(err.message)); } callback(null, farmerContact, farmerContract, data.token); }); }); }); }; /** * Negotiates a storage contract and adds the shard to the frame * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ FramesRouter.prototype.addShardToFrame = function (req, res, next) { /* jshint maxstatements: 25 */ const self = this; const Frame = this.storage.models.Frame; const Pointer = this.storage.models.Pointer; const rates = self.config.application.freeTier.up; if (req.user.isUploadRateLimited(rates.hourlyBytes, rates.dailyBytes, rates.monthlyBytes)) { log.warn('addShardToFrame: Transfer rate limited, user: %s', req.user.email); analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'User Upload Rate Limited', properties: { monthlyBytes: req.user.bytesUploaded.lastMonthBytes, dailyBytes: req.user.bytesUploaded.lastDayBytes, hourlyBytes: req.user.bytesUploaded.lastHourBytes } }); return next(new errors.TransferRateError( 'Could not add shard to frame, transfer rate limit reached.' )); } if (req.body.size &gt; MAX_SHARD_SIZE) { return next(new errors.BadRequestError('Maximum shard size ' + MAX_SHARD_SIZE + ' exceeded')); } if (Array.isArray(req.body.exclude) &amp;&amp; req.body.exclude.length &gt; constants.MAX_BLACKLIST) { return next(new errors.BadRequestError('Maximum blacklist length')); } let audit; let contr; try { audit = storj.AuditStream.fromRecords( req.body.challenges, req.body.tree ); } catch (err) { return next(new errors.BadRequestError(err.message)); } try { contr = new storj.Contract({ data_size: req.body.size, data_hash: req.body.hash, store_begin: Date.now(), store_end: Date.now() + ms('365d'), audit_count: req.body.challenges.length }); } catch (err) { return next(new errors.BadRequestError(err.message)); } let bl = Array.isArray(req.body.exclude) ? req.body.exclude : []; let frame = null; let farmer = null; let contract = null; let token = null; async.series([ function checkFrame(done) { Frame.findOne({ _id: req.params.frame, user: req.user._id }, function (err, _frame) { if (err) { return done(new errors.InternalError(err.message)); } if (!_frame) { done(new errors.NotFoundError('Frame not found')); } else { frame = _frame; done(); } }); }, function getContract(done) { // First check that we don't already have cached offers for this // shard from a previous request that timed out with offers that // arrived late. self.storage.models.Mirror.find({ shardHash: req.body.hash }).populate('contact').exec((err, mirrors) =&gt; { if (err) { log.error(err.message); } let mirror = null; if (mirrors &amp;&amp; mirrors.length) { const filtered = mirrors.filter((m) =&gt; { if (!m.contact) { log.warn('Mirror %s is missing contact in database', m._id); return false; } else if (!m.isEstablished) { return true; } return false; }); let blackListFiltered = filtered.filter((mirrorContact) =&gt; !bl.includes(mirrorContact.contact.nodeID) ); blackListFiltered.sort(utils.sortByReputation); mirror = blackListFiltered[0]; } if (!mirror) { // If we don't have any cached offers go ahead and send out // a call into the network for more offers log.debug('Requesting contract for frame: %s, shard hash: %s and size: %s', req.params.frame, req.body.hash, req.body.size); // Check if SIP6 is activated, otherwise we'll continue to use the // existing implementation. Once this has fully been deployed, this // switch can be removed and SIP6 used exclusively. let getContractForShard = self._defaults.activateSIP6 ? self._getContractForShardSIP6.bind(self) : self._getContractForShard.bind(self); getContractForShard(contr, audit, bl, res, function (err, _contact, _contract, _token) { if (err) { log.warn('Could not get contract for frame: %s and ' + 'shard hash: %s, reason: %s', req.params.frame, req.body.hash, err.message); done(new errors.ServiceUnavailableError(err.message)); } else { farmer = _contact; contract = _contract; // Only set the token if SIP6 is activated, this value will be // undefined without it. Once SIP6 is fully activated, this check // can be removed. if (self._defaults.activateSIP6) { token = _token; } done(); } }); } else { token = mirror.token; self.contracts.load(req.body.hash, function (err, item) { if (err) { item = new storj.StorageItem({ hash: req.body.hash }); } mirror.isEstablished = true; mirror.save(); farmer = storj.Contact(mirror.contact); contract = storj.Contract(mirror.contract); item.addContract(farmer, contract); item.addAuditRecords(farmer, audit); self.contracts.save(item, function (err) { if (err) { return done(new errors.InternalError(err.message)); } done(); }); }); } }); }, function getToken(done) { if (self._defaults.activateSIP6) { // There is no need to get the token seperately with SIP6, // we can skip this step. Once SIP6 is fully activated, this // step can be completely removed. return done(); } self.network.getConsignmentPointer( farmer, contract, audit, function (err, dcPointer) { if (err) { log.warn('Could not get consignment pointer for frame: %s, ' + 'shard hash: %s, reason: %s', req.params.frame, req.body.hash, err.message); done(new errors.ServiceUnavailableError(err.message)); } else { token = dcPointer.token; done(); } }); }, function addPointerToFrame(done) { let pointerData = { index: req.body.index, hash: req.body.hash, size: req.body.size, tree: req.body.tree, parity: req.body.parity, challenges: req.body.challenges }; Pointer.create(pointerData, function (err, pointer) { if (err) { return done(new errors.BadRequestError(err.message)); } // We need to reload the frame to get the latest copy Frame.findOne({ _id: frame._id }).populate('shards').exec(function (err, frame) { if (err) { return done(new errors.InternalError(err.message)); } req.user.recordUploadBytes(pointer.size, (err) =&gt; { if (err) { log.warn( 'addShardToFrame: unable to save upload bytes %s, ' + 'user: %s, reason: %s', pointer.size, req.user.email, err.message ); } }); frame.addShard(pointer, (err) =&gt; { if (err) { return done(new errors.InternalError(err.message)); } res.send({ hash: req.body.hash, token: token, operation: 'PUSH', farmer: farmer }); }); }); }); } ], next); }; /** * Destroys the file staging frame if it is not in use by a bucket entry * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ FramesRouter.prototype.destroyFrameById = function (req, res, next) { const BucketEntry = this.storage.models.BucketEntry; const Frame = this.storage.models.Frame; BucketEntry.findOne({ user: req.user._id, frame: req.params.frame }, function (err, entry) { if (err) { return next(new errors.InternalError(err.message)); } if (entry) { return next(new errors.BadRequestError( 'Refusing to destroy frame that is referenced by a bucket entry' )); } Frame.findOne({ user: req.user._id, _id: req.params.frame }, function (err, frame) { if (err) { return next(new errors.InternalError(err.message)); } if (!frame) { return next(new errors.NotFoundError('Frame not found')); } frame.remove(function (err) { if (err) { return next(new errors.InternalError(err.message)); } res.status(204).end(); }); }); }); }; /** * Returns the caller's file staging frames * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ FramesRouter.prototype.getFrames = function (req, res, next) { const Frame = this.storage.models.Frame; Frame.find({ user: req.user._id }).limit(10).exec(function (err, frames) { if (err) { return next(new errors.InternalError(err.message)); } res.send(frames.map(function (frame) { return frame.toObject(); })); }); }; /** * Returns the file staging frame by it's ID * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ FramesRouter.prototype.getFrameById = function (req, res, next) { const Frame = this.storage.models.Frame; Frame.findOne({ user: req.user._id, _id: req.params.frame }, function (err, frame) { if (err) { return next(new errors.InternalError(err.message)); } if (!frame) { return next(new errors.NotFoundError('Frame not found')); } res.send(frame.toObject()); }); }; function getStorageUsage(storage, user) { const Bucket = storage.models.Bucket; return new Promise((resolve, reject) =&gt; { var agg = Bucket.aggregate([ { $match: { user: user } }, { $lookup: { from: 'bucketentries', localField: '_id', foreignField: 'bucket', as: 'join1' } }, { $unwind: { path: '$join1' } }, { $lookup: { from: \"frames\", localField: \"join1.frame\", foreignField: \"_id\", as: \"join2\" } }, { $unwind: { path: '$join2' } }, { $project: { _id: '$join2._id', user: '$join2.user', size: '$join2.size' } }, { $group: { _id: '$user', total: { $sum: '$size' } } } ]).cursor({ batchSize: 1000 }).exec(); agg.next().then(data =&gt; { resolve(data); }).catch(err =&gt; { reject({ message: 'Error', reason: err }); }); }); } function getStorageLimit(storage, user) { return new Promise((resolve, reject) =&gt; { storage.models.User.findOne({ _id: user }, function (err, _user) { if (err) { reject({ error: 'Internal error', statusCode: 500 }); } if (!_user) { reject({ error: 'User not found', statusCode: 404 }); } if (_user.maxSpaceBytes == 0) { _user.maxSpaceBytes = 1024 * 1024 * 1024; } resolve({ error: null, statusCode: 200, maxSpaceBytes: _user.maxSpaceBytes }); }) }); } function userHasFreeSpaceLeft(storage, user) { return new Promise((resolve, reject) =&gt; { getStorageLimit(storage, user).then(limit =&gt; { const maxSpaceBytes = limit.maxSpaceBytes; getStorageUsage(storage, user).then(usage =&gt; { const usedSpaceBytes = usage ? usage.total : 0; // If !maxSpaceBytes models are not updated. Consider no limit due to this variable. resolve({ canUpload: !maxSpaceBytes ? true : usedSpaceBytes &lt; maxSpaceBytes }); }).catch(err =&gt; { resolve({ canUpload: false, error: err.message }); }); }).catch(err =&gt; { resolve({ canUpload: false, error: err.message }); }); }); } FramesRouter.prototype.getStorageUsage = function (req, res, next) { getStorageUsage(this.storage, req.user._id) .then(usage =&gt; { if (!usage) { usage = { total: 0 }; } res.status(200).send(usage); }) .catch(err =&gt; { res.status(400).send({ message: 'Error' }); }); } FramesRouter.prototype.getStorageLimit = function (req, res, next) { getStorageLimit(this.storage, req.user._id).then(result =&gt; { res.status(result.statusCode).send({ maxSpaceBytes: result.maxSpaceBytes }); }).catch(err =&gt; { res.status(result.statusCode).send({ error: err.error }); }); }; /** * Export definitions * @private */ FramesRouter.prototype._definitions = function () { /* jshint maxlen: 140 */ return [ ['POST', '/frames', this.getLimiter(limiter(1000)), this._verify, this.createFrame], ['PUT', '/frames/:frame', this.getLimiter(limiter(this._defaults.shardsPerMinute)), this._verify, this.addShardToFrame], ['DELETE', '/frames/:frame', this.getLimiter(limiter(1000)), this._verify, this.destroyFrameById], ['GET', '/frames', this.getLimiter(limiter(1000)), this._verify, this.getFrames], ['GET', '/frames/:frame', this.getLimiter(limiter(1000)), this._verify, this.getFrameById], ['GET', '/usage', this.getLimiter(limiter(1000)), this._verify, this.getStorageUsage], ['GET', '/limit', this.getLimiter(limiter(1000)), this._verify, this.getStorageLimit] ]; }; module.exports = FramesRouter; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: index.js /** * @module storj-bridge */ 'use strict'; /** {@link Engine} */ module.exports.Engine = require('./lib/engine'); /** {@link Config} */ module.exports.Config = require('./lib/config'); /** {@link Server} */ module.exports.Server = require('./lib/server'); /** {@link module:storj-bridge/utils} */ module.exports.utils = require('./lib/utils'); /** {@link module:storj-bridge/logger} */ module.exports.logger = require('./lib/logger'); × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/constants.js /** * @module storj-bridge/constants */ 'use strict'; module.exports = { /** @constant {Number} DEFAULT_FILE_TTL - File renewal interval */ DEFAULT_FILE_TTL: '365d', LOG_LEVEL_NONE: 0, LOG_LEVEL_ERROR: 1, LOG_LEVEL_WARN: 2, LOG_LEVEL_INFO: 3, LOG_LEVEL_DEBUG: 4, /** @constant {Number} M_REPLICATE - Auto-mirror degree */ M_REPLICATE: 5, /** @constant {Number} DEFAULT_MAX_ENTRIES - Used for listing entries. Should give a response size that should roughly equal 300kb. */ DEFAULT_MAX_ENTRIES: 2000, /** @constant {Number} DEFAULT_MAX_BUCKETS - Used listing buckets. Should give a response size that should roughly equal 300kb. */ DEFAULT_MAX_BUCKETS: 5000, /** @constant {Number} MAX_BUCKETENTRYNAME - The maximum length for a bucket entry. Set to the \"maximum total path length\" for Windows (32,767), to accommodate using full paths as filenames. */ MAX_BUCKETENTRYNAME: 32767, /** @constant {Number} MAX_BUCKETNAME - The maximum length for a bucketname. Set to maximum length of a file/directory name across various filesystems and operating systems (max of 255 and 260) */ MAX_BUCKETNAME: 260, /** @constant {Number} MAX_BLACKLIST - The maximum number of nodeIDs that can be blacklisted at once. */ MAX_BLACKLIST: 300 }; × Search results Close "},"lib_logger.js.html":{"id":"lib_logger.js.html","title":"Source: lib/logger.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/logger.js /** * @module storj-bridge/logger */ 'use strict'; const config = require('./config')(process.env.NODE_ENV); const CONSTANTS = require('./constants'); const Winston = require('winston'); var myCustomLevels = { levels: { error: 1, warn: 2, info: 3, debug: 4 }, colors: { error: 'red', info: 'green', debug: 'blue', warn: 'red' } }; function logLevelName(level) { var result = Object.keys(myCustomLevels.levels).filter((key, value) =&gt; { return value === level; }); if (result.length &gt; 0) { return result[0]; } else { return undefined; } } const logLevel = process.env.NODE_ENV === 'test' ? CONSTANTS.LOG_LEVEL_NONE : process.env.LOG_LEVEL || config.logger.level; module.exports = (() =&gt; { var logger = Winston.createLogger( { level: logLevelName(logLevel), levels: myCustomLevels.levels, format: Winston.format.combine( Winston.format.colorize({ all: true }), Winston.format.timestamp({ format: 'YYYY-MM-DD HH:MM:SS' }), Winston.format.splat(), Winston.format.printf(info =&gt; { return `${info.timestamp} ${info.level}: ${info.message}`; }) ), transports: [ new Winston.transports.Console() ] } ); return logger; })(); × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/utils.js /** * @module storj-bridge/utils */ 'use strict'; var through = require('through'); /** * Returns a transform stream that wraps objects written to it * in proper JSON array string */ module.exports.createArrayFormatter = function(transformer) { return through(function(entry) { if (!this._openBracketWritten) { this.queue('['); this._openBracketWritten = true; } if (this._needsPrecedingComma) { this.queue(','); } else { this._needsPrecedingComma = true; } this.queue(JSON.stringify(transformer(entry))); }, function() { if (!this._openBracketWritten) { this.queue('['); } this.queue(']'); this.queue(null); }); }; /** * Sort by reputation, to be used with Array.prototype.sort * @param {Object} - a * @param {Object} - b */ module.exports.sortByReputation = function(a, b) { const a1 = a.contact.reputation &gt;= 0 ? a.contact.reputation : 0; const b1 = b.contact.reputation &gt;= 0 ? b.contact.reputation : 0; return (a1 === b1) ? 0 : (a1 &gt; b1) ? -1 : 1; }; /** * Will get a timestamp integer from a string or number * argument, including ISO formatted strings. * @param {*} - The variable to parse */ module.exports.parseTimestamp = function(arg) { let startDate = new Date(arg); if (Number.isInteger(startDate.getTime())) { return startDate.getTime(); } const startDateTimestamp = parseInt(arg); if (Number.isInteger(startDateTimestamp)) { startDate = new Date(startDateTimestamp); } if (Number.isInteger(startDate.getTime())) { return startDate.getTime(); } return 0; }; /** * Will check to see if a variable is valid MongoDB object id * @param {*} - The variable to test */ module.exports.isValidObjectId = function(id) { if (typeof id !== 'string') { return false; } return /^[0-9a-fA-F]{24}$/.test(id); }; /** * Will expand JSON strings into objects * @param {Object|String} - A string or object with potential JSON strings */ module.exports.recursiveExpandJSON = function(value) { if (typeof value === 'string') { try { value = JSON.parse(value); } catch(e) { // noop } } if (typeof value === 'object') { for (let prop in value) { value[prop] = module.exports.recursiveExpandJSON(value[prop]); } } return value; }; × Search results Close "},"lib_monitor_index.js.html":{"id":"lib_monitor_index.js.html","title":"Source: lib/monitor/index.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/monitor/index.js 'use strict'; const async = require('async'); const assert = require('assert'); const crypto = require('crypto'); const storj = require('storj-lib'); const MonitorConfig = require('./config'); const Storage = require('storj-service-storage-models'); const ComplexClient = require('storj-complex').createClient; const MongoDBStorageAdapter = require('storj-mongodb-adapter'); const ms = require('ms'); const log = require('../logger'); const errors = require('storj-service-error-types'); const http = require('http'); /** * A long running daemon that will monitor farmers uptime and will replace * contracts associated with a farmer once the farmer is confirmed to be * offline for a duration of time. * @param {MonitorConfig} config - An instance of MonitorConfig */ function Monitor(config) { if (!(this instanceof Monitor)) { return new Monitor(config); } assert(config instanceof MonitorConfig, 'Invalid config supplied'); this.storage = null; this.network = null; this.contracts = null; this._config = config; this._timeout = null; this._running = false; this._underAttack = false; } Monitor.SIGINT_CHECK_INTERVAL = 1000; Monitor.MAX_SIGINT_WAIT = 5000; /** * Starts the Bridge instance * @param {Function} callback */ Monitor.prototype.start = function (callback) { log.info('Farmer monitor service is starting'); this.storage = new Storage( this._config.storage.mongoUrl, this._config.storage.mongoOpts, { logger: log } ); this.network = new ComplexClient(this._config.complex); this.contracts = new storj.StorageManager( new MongoDBStorageAdapter(this.storage), { disableReaper: true } ); // setup next run event this.wait(); callback(); process.on('SIGINT', this._handleSIGINT.bind(this)); process.on('exit', this._handleExit.bind(this)); process.on('uncaughtException', this._handleUncaughtException.bind(this)); }; Monitor.sortByTimeoutRate = function (a, b) { const a1 = a.contact.timeoutRate &gt;= 0 ? a.contact.timeoutRate : 0; const b1 = b.contact.timeoutRate &gt;= 0 ? b.contact.timeoutRate : 0; return (a1 === b1) ? 0 : (a1 &gt; b1) ? 1 : -1; }; /** * Gets a list of posible contacts (farmers) available to transfer the shard. */ Monitor.prototype._fetchDestinations = function (shard, callback) { this.storage.models.Mirror .find({ shardHash: shard.hash }) .populate('contact') .exec((err, results) =&gt; { if (err) { return callback(err); } const mirrors = results.filter((m) =&gt; { if (!m.contact) { log.warn('Mirror %s is missing contact in database', m._id); return false; } else if (shard.contracts[m.contact._id]) { //log.warn('Shard %s already established to contact %s', shard.hash, m.contact._id); return false; } else if (!m.isEstablished) { return true; } return false; }); mirrors.sort(Monitor.sortByTimeoutRate); callback(null, mirrors); }); }; /** * Gets a list of farmers who owns the given shard. */ Monitor.prototype._fetchSources = function (shard, callback) { let farmers = Object.keys(shard.contracts); this.storage.models.Contact .find({ _id: { $in: farmers } }) .sort({ lastSeen: -1 }) .exec((err, results) =&gt; { if (err) { return callback(err); } let contacts = []; for (let i = 0; i &lt; results.length; i++) { let c = results[i]; let contact = null; try { contact = storj.Contact(c.toObject()); } catch (e) { log.warn('Unable to fetch source, invalid contact: %j', c.toObject()); } if (contact) { contacts.push(contact); } } callback(null, contacts); }); }; Monitor.prototype._saveShard = function (shard, destination, callback) { const contract = storj.Contract(destination.contract); const contact = storj.Contact(destination.contact); shard.addContract(contact, contract); this.contracts.save(shard, (err) =&gt; { if (err) { return callback(new Error('Unable to save contract to shard')); } log.info('Successfully replicated shard %s', shard.hash); destination.isEstablished = true; destination.save((err) =&gt; { if (err) { return callback( new Error('Unable to update mirror as established, reason: ' + err.message) ); } callback(); }); }); }; Monitor.prototype._transferShard = function (shard, state, callback) { const source = state.sources[0]; const destination = state.destinations[0]; if (!source) { return callback(new Error('Sources exhausted')); } if (!destination) { return callback(new Error('Destinations exhausted')); } let contract = null; try { contract = shard.getContract(source); } catch (e) { log.warn('Unable to transfer shard, invalid contract: %j', destination.contract); state.destinations.shift(); this._transferShard(shard, state, callback); return; } this.network.getRetrievalPointer(source, contract, (err, pointer) =&gt; { if (err || !pointer) { log.warn('Failed to get retrieval pointer from farmer %s, reason: %s', source, err ? err.message : null); state.sources.shift(); this._transferShard(shard, state, callback); return; } const farmer = storj.Contact(destination.contact); this.network.getMirrorNodes([pointer], [farmer], (err) =&gt; { if (err) { log.warn('Unable to mirror to farmer %s, reason: %s', destination.contact.nodeID, err.message); state.destinations.shift(); this._transferShard(shard, state, callback); return; } this._saveShard(shard, destination, callback); }); }); }; /** * Gets a list of sources and a list of destinations of a given shard. */ Monitor.prototype._replicateShard = function (shard, callback) { async.parallel({ destinations: (next) =&gt; { this._fetchDestinations(shard, next); }, sources: (next) =&gt; { this._fetchSources(shard, next); } }, (err, state) =&gt; { if (err) { return callback(err); } this._transferShard(shard, state, callback); }); }; Monitor.prototype._removeFarmer = function (farmer) { async.parallel([ (callback) =&gt; { this.storage.models.Shard.update({ $or: [ { \"challenges.nodeID\": farmer }, { \"trees.nodeID\": farmer }, { \"contracts.nodeID\": farmer } ] }, { $pull: { \"challenges\": { nodeID: farmer }, \"trees\": { nodeID: farmer }, \"contracts\": { nodeID: farmer } } }, (err, updated) =&gt; { if (err) { log.warn('Error cleaning up SHARDS from %s, reason: %s', farmer, err); callback(1, false); } else { log.info('Total %s SHARDS from %s removed from database', updated.ok, farmer); callback(null, true); } }); }, (callback) =&gt; { this.storage.models.Mirror.deleteMany({ contact: farmer }, (err, total) =&gt; { if (err) { log.warn('Error cleaning up MIRRORS from %s, reason: %s', farmer, err); callback(1, false); } else { log.info('Total %s MIRRORS from %s removed from database', total.deletedCount, farmer); callback(null, true); } }); } ], (err, results) =&gt; { if (err) { log.warn('Error cleaning up farmer info from database %s', farmer); } else { log.info('Entries from %s removed', farmer); this.storage.models.Contact.deleteOne({ _id: farmer }, (err, contact) =&gt; { if (err) { log.warn('Error removing contact %s, reason: %s', farmer, err); } else { log.info('Contact removed from database %s', farmer); } }); } }); } Monitor.prototype._replicateFarmer = function (contact) { log.info('Starting to replicate farmer %s', contact.nodeID); // Search all shard from the offline farmer const query = { 'contracts.nodeID': contact.nodeID }; const cursor = this.storage.models.Shard.find(query).cursor(); var replicationErrors = 0; cursor .on('error', (err) =&gt; { log.error('Unable to replicate farmer %s, reason: %s', contact.nodeID, err.message); replicationErrors++; }) .on('data', (data) =&gt; { cursor.pause(); const shard = storj.StorageItem(data.toObject()); log.info('Replicating shard %s for farmer %s', shard.hash, contact.nodeID); this._replicateShard(shard, (err) =&gt; { if (err) { log.error('Unable to replicate shard %s, reason: %s', shard.hash, err.message); } cursor.resume(); }); }) .on('close', () =&gt; { log.info('Ending replication of farmer %s', contact.nodeID); if (!this._underAttack || replicationErrors == 0) { this._removeFarmer(contact.nodeID); } else { log.info('No need to remove farmer, reason: %s', (this._underAttack ? 'Under attack or CPU max.' : 'Replication errors')); } }); }; Monitor.prototype._DDosAttackCheker = function () { const trigger = 5.0; const load = parseFloat(require('fs').readFileSync('/proc/loadavg', 'utf8').trim().split(' ')[0]); this._underAttack = load &gt; trigger; if (this._underAttack) { log.warn('Server overloaded. Preventing from remove farmers'); } } Monitor.prototype.run = function () { // If a check round is being executed, wait. if (this._running) { return this.wait(); } let fail = 0; let success = 0; let total = 0; const limit = this._config.application.queryNumber || 10; const pingConcurrency = this._config.application.pingConcurrency || 10; const timeoutRateThreshold = this._config.application.timeoutRateThreshold; const finish = (err) =&gt; { if (err) { log.error(err); } log.info('Ending farmer monitor round with failure rate of %s/%s from %s', fail, success, total); //if the rate of failures is greater than 5%, let's check if we are under attack. if (fail &gt; 5) { this._DDosAttackCheker(); } this._running = false; this.wait(); }; log.info('Starting farmer monitor round for %s contacts', limit); this._running = true; // Query the least seen contacts with timeout rates below threshold const Contact = this.storage.models.Contact; const query = { $or: [ { timeoutRate: { $lt: timeoutRateThreshold } }, { timeoutRate: { $exists: false } }, { $and: [{ timeoutRate: { $gte: 0.04 } }, { $expr: { $gt: [\"$lastSeen\", \"$lastTimeout\"] } }] } ] }; const cursor = Contact.find(query).limit(limit).sort({ lastSeen: 1 }); cursor.exec((err, contacts) =&gt; { if (err) { return finish(err); } if (!contacts) { return finish( new errors.InternalError('No contacts in contacts collection') ); } // Update total length of contacts total = contacts.length; log.info(\"Total farmers found to scan: %s\", total); // Ping the least seen contacts async.eachLimit(contacts, pingConcurrency, (contactData, next) =&gt; { const contact = storj.Contact(contactData); this.network.ping(contact, (err) =&gt; { if (err) { fail += 1; log.error('Farmer %s failed ping, reason: %s', contact.nodeID, err.message); contactData.recordTimeoutFailure().save((err) =&gt; { if (err) { log.error('Unable to save ping failure, farmer: %s, reason: %s', contact.nodeID, err.message); } }); if (contactData.timeoutRate &gt;= timeoutRateThreshold) { log.warn('Shards from farmer %s must be replicated, timeoutRate: %s', contact.nodeID, contactData.timeoutRate); this._replicateFarmer(contact); } } else { success += 1; } next(); }); }, finish); }); }; Monitor.prototype._randomTime = function (max, min) { const range = max - min; assert(Number.isSafeInteger(range)); assert(range &gt; 0, 'maxInterval is expected to be greater than minInterval'); const entropy = crypto.randomBytes(8).toString('hex'); const offset = Math.round(parseInt('0x' + entropy) / Math.pow(2, 64) * range); return min + offset; }; /** * Will wait and then call `run` after a random amount of time */ Monitor.prototype.wait = function () { clearTimeout(this._timeout); const max = ms(this._config.application.maxInterval); const min = ms(this._config.application.minInterval); const milliseconds = this._randomTime(max, min); const minutes = Number(milliseconds / 1000 / 60).toFixed(2); log.info('Scheduling next round in %s minutes', minutes); this._timeout = setTimeout(() =&gt; this.run(), milliseconds); }; /** * Handles uncaught exceptions * @private */ /* istanbul ignore next */ Monitor.prototype._handleUncaughtException = function (err) { if (process.env.NODE_ENV === 'test') { throw err; } log.error('An unhandled exception occurred:', err); process.exit(1); }; /** * Handles exit event from process * @private */ /* istanbul ignore next */ Monitor.prototype._handleExit = function () { log.info('Farmer monitor service is shutting down'); }; /** * Postpones process exit until requests are fullfilled * @private */ /* istanbul ignore next */ Monitor.prototype._handleSIGINT = function () { let waitTime = 0; log.info('Received shutdown signal, checking for running monitor'); setInterval(function () { waitTime += Monitor.SIGINT_CHECK_INTERVAL; if (!this._running) { process.exit(); } if (waitTime &gt; Monitor.MAX_SIGINT_WAIT) { process.exit(); } }, Monitor.SIGINT_CHECK_INTERVAL); }; module.exports = Monitor; × Search results Close "},"lib_server_routes_pubkeys.js.html":{"id":"lib_server_routes_pubkeys.js.html","title":"Source: lib/server/routes/pubkeys.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/pubkeys.js 'use strict'; const Router = require('./index'); const middleware = require('storj-service-middleware'); const authenticate = middleware.authenticate; const errors = require('storj-service-error-types'); const inherits = require('util').inherits; const analytics = require('storj-analytics'); const limiter = require('../limiter').DEFAULTS; /** * Handles endpoints for all key related operations * @constructor * @extends {Router} */ function PublicKeysRouter(options) { if (!(this instanceof PublicKeysRouter)) { return new PublicKeysRouter(options); } Router.apply(this, arguments); this.getLimiter = middleware.rateLimiter(options.redis); this._verify = authenticate(this.storage); } inherits(PublicKeysRouter, Router); /** * Returns a list of pubkeys for the user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ PublicKeysRouter.prototype.getPublicKeys = function(req, res, next) { const PublicKey = this.storage.models.PublicKey; PublicKey.find({ user: req.user._id }, function(err, pubkeys) { if (err) { return next(new errors.InternalError(err.message)); } res.send(pubkeys.map(function(pubkey) { return pubkey.toObject(); })); }); }; /** * Registers a new public key for the user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ PublicKeysRouter.prototype.addPublicKey = function(req, res, next) { const PublicKey = this.storage.models.PublicKey; analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Key Registered' }); PublicKey.create( req.user, req.body.key, req.body.label, function(err, pubkey) { if (err) { if (err.code) { // This is a MongoDB error return next(new errors.InternalError(err.message)); } else { return next(new errors.BadRequestError(err.message)); } } res.send(pubkey.toObject()); } ); }; /** * Destroys the user's public key * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ PublicKeysRouter.prototype.destroyPublicKey = function(req, res, next) { const PublicKey = this.storage.models.PublicKey; analytics.track(req.headers.dnt, { userId: req.user.uuid, event: 'Key Destroyed' }); PublicKey.findOne({ user: req.user._id, _id: req.params.pubkey }, function(err, pubkey) { if (err) { return next(new errors.InternalError(err.message)); } if (!pubkey) { return next(new errors.NotFoundError('Public key was not found')); } pubkey.remove(function(err) { if (err) { return next(new errors.InternalError(err.message)); } res.status(204).end(); }); }); }; /** * Export definitions * @private */ PublicKeysRouter.prototype._definitions = function() { return [ ['GET', '/keys', this.getLimiter(limiter(1000)), this._verify, this.getPublicKeys], ['POST', '/keys', this.getLimiter(limiter(1000)), this._verify, this.addPublicKey], ['DELETE', '/keys/:pubkey', this.getLimiter(limiter(1000)), this._verify, this.destroyPublicKey] ]; }; module.exports = PublicKeysRouter; × Search results Close "},"lib_server_routes_reports.js.html":{"id":"lib_server_routes_reports.js.html","title":"Source: lib/server/routes/reports.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/reports.js 'use strict'; const Router = require('./index'); const log = require('../../logger'); const middleware = require('storj-service-middleware'); const errors = require('storj-service-error-types'); const inherits = require('util').inherits; const BucketsRouter = require('./buckets'); const constants = require('../../constants'); const async = require('async'); const storj = require('storj-lib'); const limiter = require('../limiter').DEFAULTS; const utils = require('../../utils'); /** * Handles endpoints for reporting * @constructor * @extends {Router} */ function ReportsRouter(options) { if (!(this instanceof ReportsRouter)) { return new ReportsRouter(options); } Router.apply(this, arguments); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(ReportsRouter, Router); /** * Creates an exchange report * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ ReportsRouter.prototype.createExchangeReport = function (req, res, next) { const self = this; var exchangeReport = new this.storage.models.ExchangeReport(req.body); var projection = { hash: true, contracts: true }; this.storage.models.Shard.find({ hash: exchangeReport.dataHash }, projection, function (err, shards) { if (err) { return next(new errors.InternalError(err.message)); } if (!shards || !shards.length) { return next(new errors.NotFoundError('Shard not found for report')); } // TODO: Add signature/identity verification // NB: Kick off mirroring if needed self._handleExchangeReport(exchangeReport, (err) =&gt; { /* istanbul ignore next */ if (err) { // If handleExchangeReport results in error (default switch), // And the error is MIRROR_FAILED // Mirror is deleted from database. if (exchangeReport.exchangeResultMessage == 'MIRROR_FAILED') { self.storage.models.Mirror.deleteOne({ shardHash: exchangeReport.dataHash, contact: exchangeReport.reportedId }, function (err, mirror) { if (err) { log.warn('Cannot delete mirror after MIRROR_FAILED'); } }); } return log.warn(err.message); } }); exchangeReport.save(function (err) { if (err) { return next(new errors.BadRequestError(err.message)); } res.status(201).send({}); }); }); }; /** * @private */ ReportsRouter.prototype._handleExchangeReport = function (report, callback) { const { dataHash, exchangeResultMessage } = report; switch (exchangeResultMessage) { case 'MIRROR_SUCCESS': case 'SHARD_UPLOADED': case 'DOWNLOAD_ERROR': this._triggerMirrorEstablish(constants.M_REPLICATE, dataHash, callback); break; default: callback(new Error('Exchange result type will not trigger action')); } // MIRROR_FAILED will run out the default switch. }; ReportsRouter._sortByTimeoutRate = function (a, b) { const a1 = a.contact.timeoutRate &gt;= 0 ? a.contact.timeoutRate : 0; const b1 = b.contact.timeoutRate &gt;= 0 ? b.contact.timeoutRate : 0; return (a1 === b1) ? 0 : (a1 &gt; b1) ? 1 : -1; }; ReportsRouter._sortByResponseTime = function (a, b) { const aTime = a.contact.responseTime || Infinity; const bTime = b.contact.responseTime || Infinity; return (aTime === bTime) ? 0 : (aTime &gt; bTime) ? 1 : -1; }; /** * Loads some mirrors for the hash and establishes them * @private */ ReportsRouter.prototype._triggerMirrorEstablish = function (n, hash, done) { const self = this; let item = null; function _loadShard(callback) { self.contracts.load(hash, (err, _item) =&gt; { if (err) { return callback(err); } item = _item; callback(); }); } function _getMirrors(callback) { self.storage.models.Mirror.find({ shardHash: hash }) .populate('contact') .exec(callback); } function _getMirrorCandidate(mirrors, callback) { let established = [], available = []; mirrors.forEach((m) =&gt; { if (!m.contact) { log.warn('Mirror %s is missing contact in database', m._id); } else if (!m.isEstablished) { available.push(m); } else { established.push(m); } }); if (available.length === 0) { return callback(new Error('No available mirrors')); } if (established.length &gt;= n) { return callback(new Error('Auto mirroring limit is reached')); } available.sort(utils.sortByReputation); callback(null, available.shift()); } function _getRetrievalTokenFromFarmer(mirror, callback) { let farmers = Object.keys(item.contracts); let pointer = null; let test = () =&gt; farmers.length === 0 || pointer !== null; let contact = storj.Contact(mirror.contact.toObject()); async.until(test, (done) =&gt; { self.getContactById(farmers.pop(), (err, result) =&gt; { if (err) { return done(); } let farmer = storj.Contact(result.toObject()); self.network.getRetrievalPointer( farmer, item.getContract(farmer), (err, result) =&gt; { // NB: Make sure that we don't set pointer to undefined // instead of null that would trigger the until loop to quit if (err) { log.warn('Unable to get pointer for mirroring, reason: %s', err.message); } else { pointer = result; } done(); } ); }); }, () =&gt; { if (!pointer) { return callback(new Error('Failed to get pointer')); } callback(null, pointer, mirror, contact); }); } function _establishMirror(source, mirror, contact, callback) { self.network.getMirrorNodes( [source], [contact], (err) =&gt; { if (err) { return callback(err); } mirror.isEstablished = true; mirror.save(); item.addContract(contact, storj.Contract(mirror.contract)); self.contracts.save(item, callback); } ); } async.waterfall([ _loadShard, _getMirrors, _getMirrorCandidate, _getRetrievalTokenFromFarmer, _establishMirror ], done); }; /** * @private */ ReportsRouter.prototype.getContactById = BucketsRouter.prototype.getContactById; /** * @private */ ReportsRouter.prototype._definitions = function () { return [ ['POST', '/reports/exchanges', this.getLimiter(limiter(1000)), middleware.rawbody, this.createExchangeReport.bind(this)] ]; }; module.exports = ReportsRouter; × Search results Close "},"lib_server_index.js.html":{"id":"lib_server_index.js.html","title":"Source: lib/server/index.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/index.js 'use strict'; const fs = require('fs'); const assert = require('assert'); const http = require('http'); const https = require('https'); const log = require('../logger'); /** * Setup HTTP(S) server for REST API * @constructor * @param {Object} options * @param {Function} app - express app or request handler */ function Server(options, app) { if (!(this instanceof Server)) { return new Server(options, app); } assert(typeof options === 'object', 'Invalid options supplied'); assert(typeof app === 'function', 'Invalid request handler supplied'); this.options = options; this.server = this._createServer(app); this.app = app; } /** * Creates the appropriate server * @private * @param {Function} handler - request handler */ Server.prototype._createServer = function(handler) { let server = null; log.info('setting up http(s) server instance'); if (this.isConfiguredForSSL()) { server = https.createServer({ cert: fs.readFileSync(this.options.ssl.cert), key: fs.readFileSync(this.options.ssl.key), ca: this.options.ssl.ca.map(function(ca) { return fs.readFileSync(ca); }) }, handler); } else { server = http.createServer(handler); } server.timeout = this.options.timeout; server.listen(this.options.port); return server; }; /** * Determines if this server should use SSL * #isConfiguredForSSL * @returns {Boolean} */ Server.prototype.isConfiguredForSSL = function() { if (!this.options.ssl) { return false; } let hasCert = !!this.options.ssl.cert; let hasKey = !!this.options.ssl.key; let hasCertAuth = Array.isArray(this.options.ssl.ca); return hasCert &amp;&amp; hasKey &amp;&amp; hasCertAuth; }; module.exports = Server; module.exports.Routes = require('./routefactory'); × Search results Close "},"lib_server_routes_stripe.js.html":{"id":"lib_server_routes_stripe.js.html","title":"Source: lib/server/routes/stripe.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/stripe.js 'use strict'; const Router = require('./index'); const inherits = require('util').inherits; const middleware = require('storj-service-middleware'); const authenticate = middleware.authenticate; const rawbody = middleware.rawbody; const limiter = require('../limiter').DEFAULTS; const errors = require('storj-service-error-types'); const log = require('../../logger'); /** * Handles endpoints for all stripe related webhooks * @constructor * @extends {Router} */ function StripeRouter(options) { if (!(this instanceof StripeRouter)) { return new StripeRouter(options); } Router.apply(this, arguments); this._verify = authenticate(this.storage); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(StripeRouter, Router); StripeRouter.prototype.getSubscription = function (req, res, next) { res.status(200).send({ ok: 'ok' }); } StripeRouter.prototype.postSubscription = function (req, res, next) { res.status(200).send({ ok: 'ok' }); } StripeRouter.prototype._webhookCheckoutSessionCompleted = function (data, res, next) { const User = this.storage.models.User; // Prevent test data overriding real users data if (!data.livemode &amp;&amp; process.env.NODE_ENV === 'production') { // return next(errors.InternalError(`Current environment can0t handle test data.`)); } const stripe = require('stripe')(data.livemode ? this.config.stripe.SK_LIVE : this.config.stripe.SK_TEST); const object = data.data.object; const subscriptionItem = object.display_items[0]; const subscriptionId = object.subscription; const customer = object.customer; const planId = subscriptionItem.plan.id; const productId = subscriptionItem.plan.product; stripe.customers.retrieve(customer, (err, customer_obj) =&gt; { const email = customer_obj.email; log.info('Webhook called by %s', email) stripe.products.retrieve(productId, (err, product) =&gt; { if (err) { log.error('Webhook error retrieving product') log.error(err); return res.status(500).send({ error: 'Error retrieving plan' }); } const metadata = product.metadata; User.findOne({ _id: email }, (err, user) =&gt; { if (err) { log.error('Webhook error updating user') log.error(err); res.status(500).send({ error: 'Cannot find user e-mail' }); } else { user.maxSpaceBytes = metadata.size_bytes; user.save(err =&gt; { if (!err) { log.info('Webhook success for %s', email) res.status(200).send(); } else { log.error('Webhook failed updating model for %s', email) res.status(500).send({ error: 'Error saving user metadata' }); } }); } }); }); }); } StripeRouter.prototype.parseWebhook = function (req, res, next) { /** * Go to stripe dashboard and enable webhook checkout.session.completed * to this endpoint */ const webhookObject = req.body; switch (webhookObject.type) { case 'checkout.session.completed': return this._webhookCheckoutSessionCompleted(webhookObject, res, next); default: return next(errors.NotImplementedError(`Webhook ${webhookObject} not implemented yet`)); } } StripeRouter.prototype._definitions = function () { return [ ['GET', '/stripe/subscription', this.getLimiter(limiter(5000)), rawbody, this.getSubscription], ['POST', '/stripe/subscription', this.getLimiter(limiter(5000)), rawbody, this.postSubscription], ['POST', '/stripe/webhook', this.getLimiter(limiter(5000)), rawbody, this.parseWebhook] ]; } module.exports = StripeRouter; × Search results Close "},"lib_server_routes_users.js.html":{"id":"lib_server_routes_users.js.html","title":"Source: lib/server/routes/users.js","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Source: lib/server/routes/users.js 'use strict'; const assert = require('assert'); const Router = require('./index'); const middleware = require('storj-service-middleware'); const rawbody = middleware.rawbody; const log = require('../../logger'); const errors = require('storj-service-error-types'); const merge = require('merge'); const inherits = require('util').inherits; const authenticate = middleware.authenticate; const crypto = require('crypto'); const storj = require('storj-lib'); const analytics = require('storj-analytics'); const limiter = require('../limiter').DEFAULTS; /** * Handles endpoints for all user related operations * @constructor * @extends {Router} */ function UsersRouter(options) { if (!(this instanceof UsersRouter)) { return new UsersRouter(options); } Router.apply(this, arguments); this._verify = authenticate(this.storage); this.getLimiter = middleware.rateLimiter(options.redis); } inherits(UsersRouter, Router); /** * Sends a user activation email * @private */ UsersRouter.prototype._dispatchActivationEmail = function (user, redir, cb) { let self = this; let profile = self.config.server.public || self.config.server; let host = profile.host; let callback = cb || storj.utils.noop; let port = [443, 80].indexOf(profile.port) === -1 ? ':' + profile.port : ''; let proto = self.config.server.ssl &amp;&amp; self.config.server.ssl.cert &amp;&amp; self.config.server.ssl.key ? 'https:' : 'http:'; self.mailer.dispatch(user.email, 'confirm', { token: user.activator, redirect: redir, url: proto + '//' + host + port }, function (err) { if (err) { log.error('failed to send activation email, reason: %s', err.message); callback(err); } else { callback(null); } }); }; /** * Sends a delayed activation email with optional `url` for beta signup * @private */ UsersRouter.prototype._dispatchDelayedActivationEmail = function (user, cb) { let self = this; self.mailer.dispatch(user.email, 'delayed-activation', {}, function (err) { if (err) { log.error('failed to send signup throttling email, reason: %s', err.message); cb(err); } else { cb(null); } }); }; /** * Sends an activation email based on configuration options * @private */ UsersRouter.prototype._dispatchActivationEmailSwitch = function (user, cb) { if (this.config.application.delayedActivation) { this._dispatchDelayedActivationEmail(user, cb); } else { this._dispatchActivationEmail(user, cb); } }; /** * Registers a new user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.createUser = function (req, res, next) { const self = this; const User = this.storage.models.User; log.debug('registering user account for %s', req.body.email); // Ensure email address is lowercase &amp; trimmed to avoid future search errors req.body.email = req.body.email.toLowerCase().trim(); if (req.body.referralPartner) { self._createUserWithOpts(req, res, next); } else { User.create(req.body.email, req.body.password, function (err, user) { if (err) { return next(err); } analytics.identify(req.headers.dnt, { userId: user.uuid, traits: { activated: false } }); analytics.track(req.headers.dnt, { userId: user.uuid, event: 'User Created' }); self._dispatchAndCreatePubKey(user, req, res, next); }); } }; /** * Dispatch activation email and create pubkey if none * @param {Object} user * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype._dispatchAndCreatePubKey = function (user, req, res, next) { const self = this; const PublicKey = this.storage.models.PublicKey; if (!req.body.pubkey) { self._dispatchActivationEmailSwitch(user, function (err) { if (err) { log.error('failed to send deactivation email, reason: %s', err.message); } }); return res.status(201).send(user.toObject()); } PublicKey.create(user, req.body.pubkey, function (err, pubkey) { if (err) { user.remove(); return next(new errors.BadRequestError(err.message)); } // NB: Don't send activation email, send beta list email // NB: Send email explaining why they cant activate yet self._dispatchActivationEmailSwitch(user, function (err) { if (err) { log.error('failed to send deactivation email, reason: %s', err.message); } }); res.status(201).send(merge(user.toObject(), { pubkey: pubkey.key })); }); }; /** * Creates user with opts object, does extra logic involved * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype._createUserWithOpts = function (req, res, next) { const self = this; const User = this.storage.models.User; const Partner = this.storage.models.Partner; const opts = { email: req.body.email, password: req.body.password }; Partner.findOne({ name: req.body.referralPartner }, function (err, partner) { if (err) { return next(err); } opts.referralPartner = partner ? partner.id : null; User.create(opts, function (err, user) { if (err) { return next(err); } analytics.identify(req.headers.dnt, { userId: user.uuid, traits: { activated: false } }); analytics.track(req.headers.dnt, { userId: user.uuid, event: 'User Created' }); if (partner) { analytics.track(req.headers.dnt, { userId: user.uuid, event: 'Referral Partner Added', traits: { referralPartner: partner.id, } }); } self._dispatchAndCreatePubKey(user, req, res, next); }); }); }; /** * Confirms a user account * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.confirmActivateUser = function (req, res, next) { const User = this.storage.models.User; log.debug('activating user with token %s', req.params.token); User.findOne({ activator: req.params.token }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.BadRequestError('Invalid activation token')); } user.activate(function (err) { if (err) { return next(new errors.InternalError(err.message)); } analytics.track(req.headers.dnt, { userId: user.uuid, event: 'User Activated' }); analytics.identify(req.headers.dnt, { userId: user.uuid, traits: { activated: true } }); if (req.query.redirect) { res.redirect(req.query.redirect); } else { res.send(user.toObject()); } }); }); }; /** * Reactivates a user account * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.reactivateUser = function (req, res, next) { const self = this; const User = this.storage.models.User; log.debug('sending account reactivation email to %s', req.body.email); User.findOne({ _id: req.body.email }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found')); } if (user.activated) { return next(new errors.BadRequestError('User is already activated')); } if (!user.activator) { user.activator = crypto.randomBytes(256).toString('hex'); user.save(function (err) { if (err) { return next(new errors.InternalError(err.message)); } self._dispatchActivationEmail(user, req.body.redirect); res.status(201).send(user.toObject()); }); } else { self._dispatchActivationEmail(user, req.body.redirect); res.status(201).send(user.toObject()); } }); }; /** * Deactivates a user account * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.destroyUser = function (req, res, next) { const self = this; const User = this.storage.models.User; log.debug('creating user deactivation token'); User.findOne({ _id: req.params.id }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found')); } if (req.user._id !== user._id) { return next(new errors.NotAuthorizedError()); } user.deactivator = crypto.randomBytes(256).toString('hex'); let profile = self.config.server.public || self.config.server; let host = profile.host; let port = [443, 80].indexOf(profile.port) === -1 ? ':' + profile.port : ''; let proto = self.config.server.ssl &amp;&amp; self.config.server.ssl.cert &amp;&amp; self.config.server.ssl.key ? 'https:' : 'http:'; self.mailer.dispatch(user.email, 'delete', { token: user.deactivator, redirect: req.body.redirect, url: proto + '//' + host + port }, function (err) { if (err) { log.error('failed to send deactivation email, reason: %s', err.message); return next(new errors.InternalError(err.message)); } user.save(function (err) { if (err) { return next(new errors.InternalError(err.message)); } res.status(200).send(user.toObject()); }); }); }); }; /** * Confirms the deletion of a user account * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.confirmDestroyUser = function (req, res, next) { const User = this.storage.models.User; log.debug('deactivating user account with token %s', req.params.token); User.findOne({ deactivator: req.params.token }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found')); } user.deactivate(function (err) { if (err) { return next(new errors.InternalError(err.message)); } if (req.query.redirect) { res.redirect(req.query.redirect); } else { res.status(200).send(user.toObject()); } }); }); }; /** * Creates a password reset token * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.createPasswordResetToken = function (req, res, next) { const self = this; const User = this.storage.models.User; User.findOne({ _id: req.params.id }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found')); } user.resetter = crypto.randomBytes(256).toString('hex'); user.save(function (err) { if (err) { return next(new errors.InternalError(err.message)); } let profile = self.config.server.public || self.config.server; let host = profile.host; let port = [443, 80].indexOf(profile.port) === -1 ? ':' + profile.port : ''; let proto = self.config.server.ssl &amp;&amp; self.config.server.ssl.cert &amp;&amp; self.config.server.ssl.key ? 'https:' : 'http:'; self.mailer.dispatch(user.email, 'reset', { token: user.resetter, redirect: req.body.redirect, url: req.body.url || proto + '//' + host + port }, function (err) { if (err) { log.error('failed to send reset email, reason: %s', err.message); return next(new errors.InternalError(err.message)); } return res.status(200).send(user.toObject()); }); }); }); }; /** * Confirms and applies the password reset * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.confirmPasswordReset = function (req, res, next) { const User = this.storage.models.User; // NB: Mitigate timing attack // NB: - attempt to make non-lookup-responses take similar // NB: - amounts of time as lookup-responses User.count({}, function (err, count) { let rand = Math.floor(Math.random() * count); function nextPlusTime(value) { User.findOne({}).skip(rand).exec(function () { // do nothing with this record next(value); }); } try { assert(Buffer(req.body.password, 'hex').length * 8 === 256); } catch (err) { return next(new errors.BadRequestError( 'Password must be hex encoded SHA-256 hash' )); } try { assert(Buffer(req.params.token, 'hex').length === 256); } catch (err) { return nextPlusTime(new Error('Resetter must be hex encoded 256 byte string')); } User.findOne({ resetter: req.params.token }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.NotFoundError('User not found')); } user.hashpass = crypto.createHash('sha256').update(req.body.password).digest('hex'); user.resetter = null; user.save(function (err) { if (err) { return next(new errors.InternalError(err.message)); } if (req.query.redirect) { res.redirect(req.query.redirect); } else { res.send(user.toObject()); } }); }); }); }; UsersRouter.prototype.subscribeUserToPlan = function (req, res, next) { const config = JSON.parse(require('fs').readFileSync(process.env.HOME + '/.storj-bridge/config/' + process.env.NODE_ENV, 'utf8')); const User = this.storage.models.User; req.params = req.body; if (!req.params.plan_id || req.params.plan_id == '') { return next(new errors.BadRequestError('No valid plan to subscribe ')); } let thePlan = config.stripe_plans.filter(o =&gt; o.plan_id == req.params.plan_id); if (thePlan == []) { return next(new errors.BadRequestError('No valid plan provided')); } const stripeUtils = require('../stripeService'); // DOES USER HAVE AN STRIPE ACCOUNT? stripeUtils.customerExists(req.user._id).then(customer =&gt; { console.log('DETERMINE USER EXISTENCE'); if (!customer) { console.log('USER DOES NOT EXISTS, CREATING NEW CUSTOMER: ' + req.user._id); if (!req.params.token) { return next(new errors.BadRequestError('No token provided')); } console.log(req.params.token); var token = JSON.parse(req.params.token).id; console.log('TOKEN ID', token); // USER DOES NOT EXISTS, CREATE stripeUtils.createNewCustomer(req.user._id, token).then(newCustomer =&gt; { if (!newCustomer) { console.log(newCustomer); return next(new errors.BadRequestError('Error creating new customer on stripe')); } console.log('NEW CUSTOMER CREATED SUCCESFULLY: ' + req.user._id); // SUBSCRIBE NEW USER TO PLAN stripeUtils.subscribeCustomerToPlan(newCustomer.id, req.params.plan_id).then(subscription =&gt; { console.log('USER ' + req.user._id + ' SUBSCRIBED'); User.findOne({ _id: req.user.id }, (err, user) =&gt; { let current_plan_info = config.stripe_plans.filter(pln =&gt; pln.plan_id == req.params.plan_id); console.log('USER FOUND: ', current_plan_info); if (!err) { user.subscriptionPlan.isSubscribed = true; user.maxSpaceBytes = current_plan_info[0].maxPlanBytes; user.subscriptionPlan = { paymentBridge: 'stripe', plan: current_plan_info[0].plan_name }; user.save(err =&gt; { if (err) { console.log(err); console.log('ERROR SAVING IN DATABASE 1'); } }); } }); res.status(200).send({ ok: 'Subscription of a new customer done' }); }).catch(err =&gt; { console.log('ERROR CREATING SUBSCRIPTION FOR ' + req.user._id); res.status(400).send({ error: err, reason: 'Cannot create subscription' }); }); }).catch(err =&gt; { console.error('CANNOT CREATE NEW USER ' + req.user._id); res.status(400).send({ error: err, reason: 'Cannot create new customer' }); }); } else { // USER DOES EXISTS, HAVE An ACTIVE PLAN ALREADY? let subscriptions = customer.data[0].subscriptions.data; console.log('--------------- SUBSCRIPTION RETRIEVED ---------------'); console.log(subscriptions); if (subscriptions.length &gt; 0) { console.log('USER HAS AN ACTIVE SUBSCRIPTION, LETS CHECK IF HE CAN UPGRADE'); console.log(subscriptions[0]); let customerId = subscriptions[0].customer; let subscription_plan = subscriptions[0].plan.id; let subscription_id = subscriptions[0].id; console.log('Current subscription id: ', subscription_id); console.log('Current subscription plan: ', subscription_plan); // CAN UPGRADE? let current_plan_info = config.stripe_plans.filter(pln =&gt; pln.plan_id == subscription_plan); console.log('current plan info: ', current_plan_info); if (current_plan_info.index == 2) { // USER ALREADY HAS THE MAX PLAN, NOT GOING TO UPGRADE console.log('Cannot upgrade, you have the highest plan'); res.status(400).send({ error: 'Cannot upgrade, you have the highest plan' }); } else { // UPGRADE PLAN console.log('CURRENT INDEX ', current_plan_info.index); console.log('USER CAN UPGRADE'); // FIRST, UNSUBCRIBE FROM THE OTHER PLAN IF IS NOT FREE PLAN if (current_plan_info.index != '0') { stripeUtils.cancelSubscriptionById(subscription_id).then(result =&gt; { console.log('Unsubscribed user: ' + current_plan_info.plan_name); stripeUtils.subscribeCustomerToPlan(customer.id, req.params.plan).then(result =&gt; { console.log('Upgrade succesful'); User.findOne({ _id: req.user.id }, (err, user) =&gt; { let current_plan_info = config.stripe_plans.filter(pln =&gt; pln.plan_id == req.params.plan_id); console.log('USER FOUND: ', current_plan_info); if (!err) { user.subscriptionPlan.isSubscribed = true; user.maxSpaceBytes = current_plan_info[0].maxPlanBytes; user.subscriptionPlan = { paymentBridge: 'stripe', plan: current_plan_info[0].plan_name }; user.save(err =&gt; { if (err) { console.log(err); console.log('ERROR SAVING IN DATABASE 2'); } }); } }); res.status(200).send({ error: 'Upgrade successful' }); }).catch(err =&gt; { console.log('Unable to subscribe to new plan after deleting the other plan'); res.status(400).send({ error: 'Error on subscription to new plan, please retry' }); }); }).catch(err =&gt; { console.log(err); console.log('Error: Cannot unsubscribe from plan'); res.status(400).send({ error: 'Error: Cannot unsubscribe from plan' }); }); } else { // USER HAS NOT FREE PLAN, LETS SUBSCRIBE HIM! stripeUtils.subscribeCustomerToPlan(customer.id, req.params.plan).then(result =&gt; { console.log('SUBSCRIPTION succesful'); User.findOne({ _id: req.user.id }, (err, user) =&gt; { let current_plan_info = config.stripe_plans.filter(pln =&gt; pln.plan_id == req.params.plan_id); console.log('USER FOUND: ', current_plan_info); if (!err) { user.subscriptionPlan.isSubscribed = true; user.maxSpaceBytes = current_plan_info[0].maxPlanBytes; user.subscriptionPlan = { paymentBridge: 'stripe', plan: current_plan_info[0].plan_name }; user.save(err =&gt; { if (err) { console.log(err); console.log('ERROR SAVING IN DATABASE 3'); } }); } }); res.status(200).send({ error: 'SUBSCRIPTION successful' }); }).catch(err =&gt; { console.log('Unable to subscribe to plan'); res.status(400).send({ error: 'Error on subscription to plan' }); }); } } } else { // USER EXISTS BUT DOES NOT HAVE A SUBSCRIPTION console.log('USER DOES NOT HAVE A SUBSCRIPTION ACTIVE, LETS SUBCRIBE HIM'); stripeUtils.subscribeCustomerToPlan(customer.data[0].id, req.params.plan_id).then(result =&gt; { console.log('SUBSCRIPTION succesful'); // TODO subscribe user plan in database User.findOne({ _id: req.user.id }, (err, user) =&gt; { let current_plan_info = config.stripe_plans.filter(pln =&gt; pln.plan_id == req.params.plan_id); console.log('USER FOUND: ', current_plan_info); if (!err) { user.subscriptionPlan.isSubscribed = true; user.maxSpaceBytes = current_plan_info[0].maxPlanBytes; user.isFreeTier = false; user.subscriptionPlan = { paymentBridge: 'stripe', plan: current_plan_info[0].plan_name }; user.save(err =&gt; { if (err) { console.log(err); console.log('ERROR SAVING IN DATABASE 4'); } }); } }); res.status(200).send({ error: 'SUBSCRIPTION successful' }); }).catch(err =&gt; { console.log('Unable to subscribe to plan', err); res.status(400).send({ error: 'Error on subscription to plan' }); }); } } }).catch(err =&gt; { console.log('CANNOT DETERMINE USER EXISTENCE'); res.status(400).send({ error: err.message }); }); } /** * Get user activation info * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @param {Function} next */ UsersRouter.prototype.isActivated = function (req, res, next) { const User = this.storage.models.User; log.debug('Getting user activation info for %s', req.headers['email']); User.findOne({ _id: req.headers['email'] }, function (err, user) { if (err) { return next(new errors.InternalError(err.message)); } if (!user) { return next(new errors.BadRequestError('User not found')); } // Send activated info res.status(200).send({ activated: user.activated }); }); }; UsersRouter.prototype.confirmDestroyUserStripe = function (req, res, next) { const self = this; const stripeUtils = require('../stripeService'); this.storage.models.User.findOne({ deactivator: req.params.token }, function (err, user) { if (err) { return next(new errors.InternalError('Error ocurred while requesting user')); } stripeUtils.customerExists(user._id).then(stripeUser =&gt; { if (stripeUser) { let subscriptions = stripeUser.data[0].subscriptions.data; if (subscriptions.length &gt; 0) { stripeUtils.cancelSubscriptionById(subscriptions[0].id).then(confirmation =&gt; { self.confirmDestroyUser(req, res, next); }).catch(err =&gt; { res.status(400).send({ error: 'Cannot cancel current plan' }); }); } else { self.confirmDestroyUser(req, res, next); } } else { self.confirmDestroyUser(req, res, next); } }); }); } /** * Export definitions * @private */ UsersRouter.prototype._definitions = function () { return [ ['POST', '/users', this.getLimiter(limiter(5)), rawbody, this.createUser], ['POST', '/activations', this.getLimiter(limiter(5)), rawbody, this.reactivateUser], ['GET', '/activations/:token', this.getLimiter(limiter(5)), this.confirmActivateUser], ['DELETE', '/users/:id', this.getLimiter(limiter(5)), this._verify, this.destroyUser], ['GET', '/deactivations/:token', this.getLimiter(limiter(5)), this.confirmDestroyUser], ['PATCH', '/users/:id', this.getLimiter(limiter(5)), rawbody, this.createPasswordResetToken], ['POST', '/resets/:token', rawbody, this.getLimiter(limiter(5)), this.confirmPasswordReset], ['GET', '/users/isactivated', this.getLimiter(limiter(5000)), rawbody, this.isActivated], ['POST', '/subscription', this.getLimiter(limiter(5)), this._verify, this.subscribeUserToPlan], ['GET', '/deactivationStripe/:token', this.getLimiter(limiter(5)), this.confirmDestroyUserStripe] ]; }; module.exports = UsersRouter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Global Methods Cleaner(config) A long running daemon that will inspect database looking for orphan documents and perform a clean up. It can be performed once a day. Parameters: Name Type Description config CleanerConfig An instance of CleanerConfig Source: lib/cleaner/index.js Monitor(config) A long running daemon that will monitor farmers uptime and will replace contracts associated with a farmer once the farmer is confirmed to be offline for a duration of time. Parameters: Name Type Description config MonitorConfig An instance of MonitorConfig Source: lib/monitor/index.js × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Modules Classes BucketsRouter Config Config ContactsRouter Engine FramesRouter PublicKeysRouter ReportsRouter Router Server StripeRouter UsersRouter × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Classes Classes BucketsRouter Config Config ContactsRouter Engine FramesRouter PublicKeysRouter ReportsRouter Router Server StripeRouter UsersRouter × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Tutorials Classes BucketsRouter Config Config ContactsRouter Engine FramesRouter PublicKeysRouter ReportsRouter Router Server StripeRouter UsersRouter × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Internxt Bridge Quick Start Install MongoDB, Git and Wget: apt-get install mongodb redis-server git wget Install NVM, Node.js and NPM: wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash source ~/.profile nvm install 8.15 Clone the repository, install dependencies: git clone https://github.com/Internxt/bridge.git &amp;&amp; cd bridge npm install &amp;&amp; npm link Start the server (set the NODE_ENV environment variable to specify the config): NODE_ENV=develop internxt-bridge Note: Internxt Bridge cannot communicate with the network on it's own, but instead must communicate with a running Internxt Complex instance. This will use the configuration file located at ~/.storj-bridge/config/develop.json. Windows Install utilizing automated script https://github.com/Storj/storj-automation/archive/master.zip The default configuration can be modified as needed. It is located at %USERPROFILE%\\.storj-bridge\\config Terms This software is released for testing purposes only. We make no guarantees with respect to its function. By using this software you agree that Internxt is not liable for any damage to your system. You also agree not to upload illegal content, content that infringes on other's IP, or information that would be protected by HIPAA, FERPA, or any similar standard. Generally speaking, you agree to test the software responsibly. We'd love to hear feedback too. × Search results Close "},"BucketsRouter.html":{"id":"BucketsRouter.html","title":"Class: BucketsRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: BucketsRouter BucketsRouter new BucketsRouter() Handles endpoints for all bucket and file related operations Source: lib/server/routes/buckets.js Extends Router Methods _getBucketById(bucketId [, userId], callback) Returns the bucket by ID Parameters: Name Type Argument Description bucketId String | ObjectId The unique _id for the bucket userId String &lt;optional&gt; The email address for the user callback BucketsRouter~_getBucketByIdCallback Source: lib/server/routes/buckets.js createBucket(req, res, next) Creates a new bucket for the user Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js createBucketToken(req, res, next) Creates a bucket operation token Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js createEntryFromFrame(req, res, next) Creates a bucket entry from the given frame object Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js createMirrorsFromTokenMap(tokenMap, next) Establishes mirrors for a given token map Parameters: Name Type Description tokenMap Array.&lt;Array&gt; next BucketsRouter~createMirrorsFromTokenMapCallback Source: lib/server/routes/buckets.js destroyBucketById(req, res, next) Destroys the user's bucket by ID Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js getBucketById(req, res, next) Returns the user's bucket by it's ID Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js getBucketEntryById(bucketId, bucketEntryId, done) Returns the bucket entry by ID Parameters: Name Type Description bucketId String | ObjectId The unique _id for the bucket bucketEntryId String The unique _id for the bucket entry done BucketsRouter~_getBucketEntryByIdCallback Source: lib/server/routes/buckets.js getBuckets(req, res, next) Returns a list of buckets for the user Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js getContactById(nodeId, callback) Retreives a contact by it's Node ID Parameters: Name Type Description nodeId String Farmers public key hash callback BucketsRouter~getContactByIdCallback Source: lib/server/routes/buckets.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array getFile(req, res, next) Negotiates retrieval tokens from the farmers storing the shards Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js getMirrorAuthorization(mirror, done) Authorizes a mirror node to retreive data from a source Parameters: Name Type Description mirror Mirror The mirror object done BucketsRouter~getMirrorAuthorizationCallback Source: lib/server/routes/buckets.js getMirroringTokens(mirrorMap, next) Creates a mirror authorization pointer map Parameters: Name Type Description mirrorMap Array.&lt;Array.&lt;Mirror&gt;&gt; next BucketsRouter~getMirroringTokensCallback Source: lib/server/routes/buckets.js getMirrorsForPointers(shardPointer, callback) Returns possible mirroring candidates for a group of pointers Parameters: Name Type Description shardPointer Pointer callback BucketsRouter~getMirrorsForPointersCallback Source: lib/server/routes/buckets.js getPointersForEntry(bucketEntry, next) Returns the pointers for a given bucket entry Parameters: Name Type Description bucketEntry BucketEntry next BucketsRouter~getPointersForEntryCallback Source: lib/server/routes/buckets.js listFilesInBucket(req, res, next) Lists the file pointers stored in the given bucket Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js listMirrorsForFile(req, res, next) Lists all the established mirrors for a file Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js removeFile(req, res, next) Removes the file pointer from the bucket Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js updateBucketById(req, res, next) Updates the given bucket's properties Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/buckets.js Type Definitions _getBucketByIdCallback(error, bucket) Parameters: Name Type Description error Error | null bucket Bucket Source: lib/server/routes/buckets.js _getBucketEntryByIdCallback(error, bucketEntry) Parameters: Name Type Description error Error | null bucketEntry BucketEntry Source: lib/server/routes/buckets.js _getBucketUnregisteredCallback( [error], bucket) Parameters: Name Type Argument Description error Error | null &lt;optional&gt; bucket Bucket Source: lib/server/routes/buckets.js _getPointersFromEntryCallback( [error], pointers) Parameters: Name Type Argument Description error Error | null &lt;optional&gt; pointers Array.&lt;Object&gt; Source: lib/server/routes/buckets.js _getRetrievalTokenCallback( [error], dataChannelPointer) Parameters: Name Type Argument Description error Error | null &lt;optional&gt; dataChannelPointer Object Properties Name Type Description token String hash String farmer Contact operation String size Number Source: lib/server/routes/buckets.js _requestRetrievalPointerCallback( [error] [, dataChannelPointer]) Parameters: Name Type Argument Description error Error | null &lt;optional&gt; dataChannelPointer Object &lt;optional&gt; Properties Name Type Argument Description token String &lt;optional&gt; hash String &lt;optional&gt; farmer Contact &lt;optional&gt; operation String &lt;optional&gt; Source: lib/server/routes/buckets.js createMirrorsFromTokenMapCallback(error, mirroredNodes) Parameters: Name Type Description error Error | null mirroredNodes Array.&lt;Array.&lt;Contact&gt;&gt; Source: lib/server/routes/buckets.js getContactByIdCallback(error, contact) Parameters: Name Type Description error Error | null contact Contact Source: lib/server/routes/buckets.js getMirrorAuthorizationCallback(error, mirrorAuth) Parameters: Name Type Description error Error | null mirrorAuth Object Properties Name Type Description mirror Mirror source DataChannelPointer destination Contact Source: lib/server/routes/buckets.js getMirroringTokensCallback(error, tokenMap) Parameters: Name Type Description error Error | null tokenMap Array.&lt;Array&gt; Properties Name Type Description mirror Mirror source DataChannelPointer destination Contact Source: lib/server/routes/buckets.js getMirrorsForPointersCallback(error, mirrors) Parameters: Name Type Description error Error | null mirrors Array.&lt;Array.&lt;Mirror&gt;&gt; Source: lib/server/routes/buckets.js getPointersForEntryCallback(error, shardPointers) Parameters: Name Type Description error Error | null shardPointers Array.&lt;Pointers&gt; Source: lib/server/routes/buckets.js × Search results Close "},"Config.html":{"id":"Config.html","title":"Class: Config","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: Config Config new Config(arg) Represents a configuration Parameters: Name Type Description arg String | Object Source: lib/config.js Class: Config Config new Config(arg) Represents a configuration Parameters: Name Type Description arg String | Object Source: lib/monitor/config.js × Search results Close "},"ContactsRouter.html":{"id":"ContactsRouter.html","title":"Class: ContactsRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: ContactsRouter ContactsRouter new ContactsRouter() Handles endpoints for all contact related endpoints Source: lib/server/routes/contacts.js Extends Router Methods getContactByNodeID(req, res, next) Returns the contact information for the given nodeID Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/contacts.js getContactList(req, res, next) Lists the contacts according the the supplied query Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/contacts.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array × Search results Close "},"Engine.html":{"id":"Engine.html","title":"Class: Engine","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: Engine Engine new Engine(config) Primary interface to Bridge (the glue) Parameters: Name Type Description config Config Source: lib/engine.js Methods getSpecification() Returns a dictionary of info about the service Source: lib/engine.js Returns: Type Object start(callback) Starts the Bridge instance Parameters: Name Type Description callback function Source: lib/engine.js × Search results Close "},"FramesRouter.html":{"id":"FramesRouter.html","title":"Class: FramesRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: FramesRouter FramesRouter new FramesRouter() Handles endpoints for all frame/file staging related operations Source: lib/server/routes/frames.js Extends Router Methods addShardToFrame(req, res, next) Negotiates a storage contract and adds the shard to the frame Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/frames.js createFrame(req, res, next) Creates a file staging frame Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/frames.js destroyFrameById(req, res, next) Destroys the file staging frame if it is not in use by a bucket entry Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/frames.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array getFrameById(req, res, next) Returns the file staging frame by it's ID Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/frames.js getFrames(req, res, next) Returns the caller's file staging frames Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/frames.js × Search results Close "},"module-storj-bridge.html":{"id":"module-storj-bridge.html","title":"Module: storj-bridge","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Module: storj-bridge Source: index.js Members &lt;static&gt; Config Config Source: index.js &lt;static&gt; Engine Engine Source: index.js &lt;static&gt; logger module:storj-bridge/logger Source: index.js &lt;static&gt; Server Server Source: index.js &lt;static&gt; utils module:storj-bridge/utils Source: index.js × Search results Close "},"module-storj-bridge_constants.html":{"id":"module-storj-bridge_constants.html","title":"Module: storj-bridge/constants","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Module: storj-bridge/constants Source: lib/constants.js Members &lt;inner, constant&gt; DEFAULT_FILE_TTL :Number File renewal interval Type: Number Source: lib/constants.js &lt;inner, constant&gt; DEFAULT_MAX_BUCKETS :Number Used listing buckets. Should give a response size that should roughly equal 300kb. Type: Number Source: lib/constants.js &lt;inner, constant&gt; DEFAULT_MAX_ENTRIES :Number Used for listing entries. Should give a response size that should roughly equal 300kb. Type: Number Source: lib/constants.js &lt;inner, constant&gt; M_REPLICATE :Number Auto-mirror degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_BLACKLIST :Number The maximum number of nodeIDs that can be blacklisted at once. Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_BUCKETENTRYNAME :Number The maximum length for a bucket entry. Set to the \"maximum total path length\" for Windows (32,767), to accommodate using full paths as filenames. Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_BUCKETNAME :Number The maximum length for a bucketname. Set to maximum length of a file/directory name across various filesystems and operating systems (max of 255 and 260) Type: Number Source: lib/constants.js × Search results Close "},"module-storj-bridge_logger.html":{"id":"module-storj-bridge_logger.html","title":"Module: storj-bridge/logger","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Module: storj-bridge/logger Source: lib/logger.js × Search results Close "},"module-storj-bridge_utils.html":{"id":"module-storj-bridge_utils.html","title":"Module: storj-bridge/utils","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Module: storj-bridge/utils Source: lib/utils.js Methods &lt;static&gt; createArrayFormatter() Returns a transform stream that wraps objects written to it in proper JSON array string Source: lib/utils.js &lt;static&gt; isValidObjectId(id) Will check to see if a variable is valid MongoDB object id Parameters: Name Type Description id * The variable to test Source: lib/utils.js &lt;static&gt; parseTimestamp(arg) Will get a timestamp integer from a string or number argument, including ISO formatted strings. Parameters: Name Type Description arg * The variable to parse Source: lib/utils.js &lt;static&gt; recursiveExpandJSON(value) Will expand JSON strings into objects Parameters: Name Type Description value Object | String A string or object with potential JSON strings Source: lib/utils.js &lt;static&gt; sortByReputation(a, b) Sort by reputation, to be used with Array.prototype.sort Parameters: Name Type Description a Object a b Object b Source: lib/utils.js × Search results Close "},"PublicKeysRouter.html":{"id":"PublicKeysRouter.html","title":"Class: PublicKeysRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: PublicKeysRouter PublicKeysRouter new PublicKeysRouter() Handles endpoints for all key related operations Source: lib/server/routes/pubkeys.js Extends Router Methods addPublicKey(req, res, next) Registers a new public key for the user Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/pubkeys.js destroyPublicKey(req, res, next) Destroys the user's public key Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/pubkeys.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array getPublicKeys(req, res, next) Returns a list of pubkeys for the user Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/pubkeys.js × Search results Close "},"ReportsRouter.html":{"id":"ReportsRouter.html","title":"Class: ReportsRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: ReportsRouter ReportsRouter new ReportsRouter() Handles endpoints for reporting Source: lib/server/routes/reports.js Extends Router Methods createExchangeReport(req, res, next) Creates an exchange report Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/reports.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array × Search results Close "},"Router.html":{"id":"Router.html","title":"Class: Router","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: Router Router new Router(options) Abstract representation of a route series Parameters: Name Type Description options Object Properties Name Type Description config Config network complex.Client storage Storage mailer Mailer Source: lib/server/routes/index.js Methods getEndpointDefinitions() Returns the result of the private _definitions method Source: lib/server/routes/index.js Returns: Type Array × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: Server Server new Server(options, app) Setup HTTP(S) server for REST API Parameters: Name Type Description options Object app function express app or request handler Source: lib/server/index.js Methods isConfiguredForSSL() Determines if this server should use SSL #isConfiguredForSSL Source: lib/server/index.js Returns: Type Boolean × Search results Close "},"StripeRouter.html":{"id":"StripeRouter.html","title":"Class: StripeRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: StripeRouter StripeRouter new StripeRouter() Handles endpoints for all stripe related webhooks Source: lib/server/routes/stripe.js Extends Router Methods getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array × Search results Close "},"UsersRouter.html":{"id":"UsersRouter.html","title":"Class: UsersRouter","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Class: UsersRouter UsersRouter new UsersRouter() Handles endpoints for all user related operations Source: lib/server/routes/users.js Extends Router Methods _createUserWithOpts(req, res, next) Creates user with opts object, does extra logic involved Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js _dispatchAndCreatePubKey(user, req, res, next) Dispatch activation email and create pubkey if none Parameters: Name Type Description user Object req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js confirmActivateUser(req, res, next) Confirms a user account Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js confirmDestroyUser(req, res, next) Confirms the deletion of a user account Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js confirmPasswordReset(req, res, next) Confirms and applies the password reset Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js createPasswordResetToken(req, res, next) Creates a password reset token Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js createUser(req, res, next) Registers a new user Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js destroyUser(req, res, next) Deactivates a user account Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js getEndpointDefinitions() Returns the result of the private _definitions method Inherited From: Router#getEndpointDefinitions Source: lib/server/routes/index.js Returns: Type Array isActivated(req, res, next) Get user activation info Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js reactivateUser(req, res, next) Reactivates a user account Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse next function Source: lib/server/routes/users.js × Search results Close "},"tutorial-auth.html":{"id":"tutorial-auth.html","title":"Tutorial: API Authentication","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor API Authentication Bridge understands 3 methods for authentication, which can vary depending on the operation you wish to perform. HTTP Basic HTTP Basic authentication is supported as a fallback for situations where key management is not available or specifically for use before a public key has been associated with your user account. Your username should simply be your registered email address. Your password should be the SHA-256 hash of your password. ECDSA Signatures Once you have added a public ECDSA key to your account, you can use your private key to sign messages to the server to avoid sending your credentials in every request. This is the recommended authentication method. The string that you are expected to sign differs depending on the type of request. For POST, PUT, and PATCH requests, you must sign the JSON encoded body of the request. For GET, DELETE, and OPTIONS requests, you must sign the raw query string parameters. In addition to the parameters required for each individual request, you must also include a __nonce parameter. This value should be a string and must be unique with every request. A common practice is to simply use UUID v4. In addition to the request parameters and nonce, you will also sign the HTTP method and request path. Ultimately the string you will sign will be: &lt;METHOD&gt;\\n&lt;PATH&gt;\\n&lt;PARAMS&gt; For example, to generate a signature for creating a new storage bucket, you will sign: POST\\n/buckets\\n{\"storage\":10,\"transfer\":30,\"name\":\"MyBucket\",\"__nonce\":1453222669376} This tells the server that at Tue Jan 19 2016 11:57:49 GMT-0500 (EST), you authorized a request to created a bucket called \"MyBucket\" with 10GB of capacity and 30GB of transfer. This request cannot be replayed, since the nonce cannot be reused. Once you have generated the signature, it must be encoded as HEX and included in the x-signature header. In addition you must supply the public key for verifying the signature in the x-pubkey header. Bridge will first lookup the user account to which the supplied public key is registered and then use it to verify the signature. OpenSSL Example Create ECDSA private key and print out public key openssl ecparam -genkey -name secp256k1 -noout -outform DER -out private.key openssl ec -inform DER -in private.key -noout -text Register public key (HTTP basic auth) curl -u user:password -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{ \"key\": \"043874de22536decc5508257cc806a9e5af5e8be6a80056843d5c0c2b112903430f9a46c128ca17e30e2fb54f541416185dda2df878adbb90d66811452f4162125\" }' 'https://api.storj.io/keys' Generate signature and use it for POST API call printf \"POST\\n/buckets\\n{\\\"storage\\\":10,\\\"transfer\\\":30,\\\"name\\\":\\\"MyBucket\\\",\\\"__nonce\\\":1453222669376}\" | openssl dgst -sha256 -hex -sign private.key -keyform DER curl --header \"x-signature:3046022100e5b534eba11f19d4e3e92398e4ffdf8195041a7de13a1ffe8eb3baf66eb694b8022100982837e3b449fc9e4524009acd03800abf6447cf225a83d6f21bfa67a8326465\" --header \"x-pubkey:043874de22536decc5508257cc806a9e5af5e8be6a80056843d5c0c2b112903430f9a46c128ca17e30e2fb54f541416185dda2df878adbb90d66811452f4162125\" -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{\"storage\":10,\"transfer\":30,\"name\":\"MyBucket\",\"__nonce\":1453222669376}' 'https://api.storj.io/buckets' Generate signature and use it for GET API call printf \"GET\\n/buckets\\n__nonce=1453222669376\" | openssl dgst -sha256 -hex -sign private.key -keyform DER curl --header \"x-signature:304602210099eeb8f525ea1b1f385b8c3caba43a3e1efcc8fd839e8887528dd2fd6a4ae56b022100dfd0b7501d7fba047788fe0aef4d4868c8c493568f469d2cb42ecc998ad97ad6\" --header \"x-pubkey:04bb548b98f7d11d07384187fbdefc21f5c28b88c00ad0f1d3245e80d5f168273261558d4699f0a7d5cf2a82f937b50fe3f1c234256bb2d9f5e996e86576dc2d73\" -X GET 'https://api.storj.io/buckets?__nonce=1453222669376' Single Use Tokens There are 2 cases where signing the request body is not efficient for the client and verifying the signature is not efficient for the server. This is when the user wishes to push or pull data to or from a bucket. If a file is quite large, the server would have to buffer it's entire contents in order to verify the signature. This is where single-use tokens come into play. Instead of signing the upload request, you sign a request for a token that corresponds to a bucket, then use that token in the x-token header in your upload request. This also provides a way for users to grant access to others to upload files to their bucket by generating a token for them (since anyone with the token may upload the file to the bucket). Tokens can be configured to expire (default is 5 minutes) and may only be used once. × Search results Close "},"tutorial-config_.html":{"id":"tutorial-config_.html","title":"Tutorial: Configuring the Bridge","body":" Internxt API Modules storj-bridgestorj-bridge/constantsstorj-bridge/loggerstorj-bridge/utils Classes BucketsRouterConfigContactsRouterEngineFramesRouterPublicKeysRouterReportsRouterRouterServerStripeRouterUsersRouter Tutorials API AuthenticationConfiguring the Bridge Global CleanerMonitor Configuring the Bridge The Config class provides an interface for reading configuration files. Bridge stores configuration in it's data directory which is located in $HOME/.storj-bridge. A configuration is loaded by supplying the constructor with an env or \"environment\" string. The env string should correspond to a filename located in the $HOME/.storj-bridge/config directory. When creating an instance of Config, the supplied configuration is loaded from disk and used to overload the default configuration. Once you have an instance of Config, you can access it's properties simply by using standard dot-syntax. Parameter Default Description storage.name null The name of the database that Bridge will use. It should be changed as to not conflict with running tests. storage.user null The username for your database. You should set a username and password unless your DB instance is only listening locally. storage.pass null Same as above. server.host 127.0.0.1 If your public IP is not bound to an interface on your host, you can set this to the IP bound to the interface with access to the internet or the network that Bridge traffic will travel accross. If you set this to a non public IP, you will also need to be sure to set the server.public.host. server.public.host 127.0.0.1 The hosts public IP address or a DNS record that resolves to the public IP address of the Bridge server. You only need to set this if server.host is set to a non public accessible IP address. complex.rpcUrl http://localhost:8080 The URI for the storj complex service. Set this to the instance you have configured complex.rpcUser username The user name for authenticating with the Complex server complex.rpcPassword password the password for authenticating with the Complex server The following is a sanitized version of the config that we use to run our Bridge servers. You can find the defaults in lib/config.js. { \"server\": { \"host\": \"api.storj.io\", \"timeout\": 60000, \"port\": 8080, \"ssl\": { \"cert\": true } }, \"storage\": [ { \"name\": \"bridge\", \"host\": \"123.123.123.123\", \"port\": 27017, \"ssl\": true, \"user\": \"db_user\", \"pass\": \"super_strong_db_password\", \"mongos\": { \"checkServerIdentity\": false, \"ssl\": true, \"sslValidate\": false } }, { \"name\": \"bridge\", \"host\": \"123.123.123.123\", \"port\": 27017, \"ssl\": true, \"user\": \"db_user\", \"pass\": \"super_strong_db_password\", \"mongos\": { \"checkServerIdentity\": false, \"ssl\": true, \"sslValidate\": false } }, { \"name\": \"bridge\", \"host\": \"123.123.123.123\", \"port\": 27017, \"ssl\": true, \"user\": \"db_user\", \"pass\": \"super_strong_db_password\", \"mongos\": { \"checkServerIdentity\": false, \"ssl\": true, \"sslValidate\": false } } ], \"mailer\": { \"host\": \"smtp.myemail.com\", \"port\": 465, \"auth\": { \"user\": \"robot@storj.io\", \"pass\": \"super_awesome_password\" }, \"secure\": true, \"from\": \"robot@storj.io\" }, \"complex\": { \"rpcUrl\": \"http://localhost:8080\", \"rpcUser\": \"username\", \"rpcPassword\": \"password\" } } × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
